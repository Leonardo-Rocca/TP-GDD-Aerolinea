/*
USE[GD2C2015];
GO
*/

/* -- Nuevo esquema -- */

--CREATE SCHEMA [DBAS] AUTHORIZATION [gd];
--GO

/* -- Tablas y Constraints -- */

-- DDL de tablas

CREATE TABLE DBAS.rutas (
	codigo_ruta bigint IDENTITY(1,1) PRIMARY KEY,
	codigo_ruta_original bigint,
	ciudad_origen_id bigint,
	ciudad_destino_id bigint,
	precio_base_por_KG float(24),
	precio_base_por_pasaje float(24),
	habilitada_ruta tinyint default 1
);
GO

CREATE TABLE DBAS.viajes (
	id_viaje bigint IDENTITY(1,1) PRIMARY KEY,
	fecha_salida datetime,
	fecha_llegada datetime,
	fecha_llegada_estimada datetime,
	matricula_aeronave varchar(100),
	codigo_ruta bigint,
	habilitado_viaje tinyint default 1,
	CHECK( (fecha_llegada_estimada <= DATEADD(day, 1, fecha_salida)) AND (fecha_salida < fecha_llegada))
);
GO

CREATE TABLE DBAS.aeronaves (
	matricula_aeronave varchar(100) PRIMARY KEY,
	numero_aeronave bigint IDENTITY(1,1) UNIQUE,
	modelo_aeronave varchar(100),
	fecha_reinsercion datetime,
	fecha_baja_servicio_definitiva datetime,
	kg_disponible_encomienda float(24),
	id_fabricante bigint,
 	id_servicio bigint

);
GO

CREATE TABLE DBAS.fabricantes (
	id_fabricante bigint IDENTITY(1,1) PRIMARY KEY,
	nombre_fabricante varchar(50)
);
GO

CREATE TABLE DBAS.butacas (
	id_butaca bigint IDENTITY(1,1) PRIMARY KEY,
	numero_butaca smallint,
	tipo_butaca varchar(15) CHECK(tipo_butaca IN('Pasillo','Ventanilla','0')),
	piso_butaca tinyint,
	matricula_aeronave varchar(100) NOT NULL,
	UNIQUE(numero_butaca, matricula_aeronave, piso_butaca)
);
GO

CREATE TABLE DBAS.pasajes (
	codigo_pasaje bigint IDENTITY(1,1) PRIMARY KEY,
	id_cliente  bigint NOT NULL,
	id_viaje bigint NOT NULL,
	id_butaca bigint,
	fecha_compra_pasaje datetime,
	precio_pasaje float(24),
	id_compra_PNR bigint,
	id_cancelacion bigint
);
GO

CREATE TABLE DBAS.encomiendas (
	codigo_encomienda bigint IDENTITY(1,1) PRIMARY KEY,
	id_cliente bigint NOT NULL,
	encomienda_cliente_KG float(24),
	id_viaje bigint NOT NULL,
	fecha_compra_encomienda datetime,
	precio_encomienda float(24),
	id_compra_PNR bigint,
	id_cancelacion bigint
);

CREATE TABLE DBAS.servicios (
	id_servicio bigint IDENTITY(1,1) PRIMARY KEY,
	porcentaje_arancel float(24),
	tipo_servicio varchar(50)
);
GO

CREATE TABLE DBAS.serviciosPorRutas (
	codigo_ruta bigint NOT NULL,
	id_servicio bigint NOT NULL
);
GO

CREATE TABLE DBAS.compras (
	id_compra_PNR bigint IDENTITY(1,1) PRIMARY KEY,
	id_cliente bigint NOT NULL,
	tarjeta_id bigint
);
GO

CREATE TABLE DBAS.tarjetas (
	tarjeta_id bigint IDENTITY(1,1) PRIMARY KEY,
	tarjeta_Numero bigint,
	tarjeta_Codigo bigint,
	tarjeta_Fecha_de_vencimiento datetime,
	tipo_tarjeta_id bigint,
	cuoatas_elegidas smallint
	
);

CREATE TABLE DBAS.tiposTarjeta (
	tipo_tarjeta_id bigint IDENTITY(1,1) PRIMARY KEY,
	descripcion_tipo varchar(10),
	cuotas smallint
	
);

CREATE TABLE DBAS.roles (
	id_rol bigint IDENTITY(1,1) PRIMARY KEY,
	nombre_rol varchar(100),
	habilitado_rol tinyint default 1
);
GO

CREATE TABLE DBAS.rolesPorFuncionalidad (
	id_rol bigint NOT NULL,
	id_funcionalidad bigint NOT NULL,
);
GO

CREATE TABLE DBAS.funcionalidades (
	id_funcionalidad bigint IDENTITY(1,1) PRIMARY KEY,
	descripcion varchar(100)
);
GO

CREATE TABLE DBAS.cancelaciones (
	id_cancelacion bigint IDENTITY(1,1) PRIMARY KEY,
	fecha_devolucion datetime,
	motivo_cancelacion varchar(100),
);
GO

CREATE TABLE DBAS.usuarios (
	id_usuario bigint PRIMARY KEY,
	username varchar(50) UNIQUE,
	password varchar(250),
	intentos_fallidos tinyint default 0,
	habilitado tinyint default 1,
);
GO

CREATE TABLE DBAS.usuariosPorRol (
	id_usuario bigint NOT NULL,
	id_rol bigint NOT NULL
);
GO

CREATE TABLE DBAS.ciudades (
	id_ciudad bigint IDENTITY(1,1) PRIMARY KEY,
	nombre_ciudad varchar(100),
	habilitada_ciudad tinyint default 1
);
GO

CREATE TABLE DBAS.clientes (
	id_cliente bigint  IDENTITY(1,1) PRIMARY KEY,
	id_persona bigint NOT NULL,
);
GO

CREATE TABLE DBAS.personas (
	id_persona bigint IDENTITY(1,1) PRIMARY KEY,
	dni_persona bigint NOT NULL,
	nombre_persona varchar(100) NOT NULL,
	apellido_persona varchar(100) NOT NULL,
	direccion_persona varchar(100),
	telefono_persona varchar(50),
	mail_persona varchar(100),
	fecha_nacimiento datetime,
);
GO

CREATE TABLE DBAS.canjes (
	id_canje bigint IDENTITY(1,1) PRIMARY KEY,
	id_cliente bigint,
	fecha_canje datetime,
	cantidad_producto bigint,
	millas_usadas bigint,
	id_producto bigint
	
);
GO

CREATE TABLE DBAS.productos (
	id_producto bigint IDENTITY(1,1) PRIMARY KEY,
	valor_en_milas int,
	nombre_producto varchar(100),
	stock int
);
GO

CREATE TABLE DBAS.periodosFueraDeServicio (
	id_periodo bigint IDENTITY(1,1) PRIMARY KEY,
	matricula_aeronave varchar(100),
	fecha_fuera_servicio datetime,
	fecha_reinicio_servicio datetime
);
GO

CREATE TABLE DBAS.date_time (
	id_periodo tinyint PRIMARY KEY default 1,
	GET_DATE datetime default GETDATE(),
);
GO

--DDL de constraints compuestos

alter table DBAS.serviciosPorRutas add constraint pk_serviciosPorRutas
	primary key clustered (codigo_ruta,	id_servicio);
GO

alter table DBAS.rolesPorFuncionalidad add constraint pk_rolesPorFuncionalidad 
	primary key clustered (id_rol, id_funcionalidad);
GO

alter table DBAS.usuariosPorRol add constraint pk_usuariosPorRol
	primary key clustered (id_usuario, id_rol);
GO

-- DDL de constraints FK

alter table DBAS.rutas add constraint fk_ruta_ciudadOrigen 
	foreign key (ciudad_origen_id) references DBAS.ciudades (id_ciudad);
GO

alter table DBAS.rutas add constraint fk_ruta_ciudadDestino 
	foreign key (ciudad_destino_id) references DBAS.ciudades (id_ciudad);
GO

alter table DBAS.viajes add constraint fk_viaje_aeronave 
	foreign key (matricula_aeronave) references DBAS.aeronaves (matricula_aeronave);
GO	

alter table DBAS.viajes add constraint fk_viaje_ruta
	foreign key (codigo_ruta) references DBAS.rutas (codigo_ruta);
GO

alter table DBAS.aeronaves add constraint fk_aeronave_fabricante
	foreign key (id_fabricante) references DBAS.fabricantes (id_fabricante);
GO 
	
alter table DBAS.aeronaves add constraint fk_aeronave_servicio
	foreign key (id_servicio) references DBAS.servicios (id_servicio);
GO 

alter table DBAS.butacas add constraint fk_butaca_aeronave
	foreign key (matricula_aeronave) references DBAS.aeronaves (matricula_aeronave);
GO

alter table DBAS.pasajes add constraint fk_pasaje_cliente
	foreign key (id_cliente) references DBAS.clientes (id_cliente); 
GO

alter table DBAS.pasajes add constraint fk_pasaje_butaca
	foreign key (id_butaca) references DBAS.butacas (id_butaca);
GO

alter table DBAS.pasajes add constraint fk_pasaje_compra
	foreign key (id_compra_PNR) references DBAS.compras (id_compra_PNR);
GO

alter table DBAS.pasajes add constraint fk_pasaje_viaje
	foreign key (id_viaje) references DBAS.viajes (id_viaje);
GO

alter table DBAS.pasajes add constraint fk_pasaje_cancelacion
	foreign key (id_cancelacion) references DBAS.cancelaciones (id_cancelacion);
GO

alter table DBAS.encomiendas add constraint fk_encomienda_cliente
	foreign key (id_cliente) references DBAS.clientes (id_cliente); 
GO

alter table DBAS.encomiendas add constraint fk_encomienda_compra
	foreign key (id_compra_PNR) references DBAS.compras (id_compra_PNR);
GO

alter table DBAS.encomiendas add constraint fk_encomienda_viaje
	foreign key (id_viaje) references DBAS.viajes (id_viaje);
GO

alter table DBAS.encomiendas add constraint fk_encomienda_cancelacion
	foreign key (id_cancelacion) references DBAS.cancelaciones (id_cancelacion);
GO

alter table DBAS.compras add constraint fk_compra_cliente
	foreign key (id_cliente ) references DBAS.clientes (id_cliente);
GO

alter table DBAS.compras add constraint fk_compra_tarjeta
	foreign key (tarjeta_id) references DBAS.tarjetas (tarjeta_id);
GO

alter table DBAS.tarjetas add constraint fk_tarjeta_tipoTarjeta
	foreign key (tipo_tarjeta_id) references DBAS.tiposTarjeta (tipo_tarjeta_id);
GO

alter table DBAS.clientes add constraint fk_cliente_persona
	foreign key (id_persona) references DBAS.personas (id_persona);
GO

alter table DBAS.canjes add constraint fk_canje_cliente
	foreign key (id_cliente) references DBAS.clientes (id_cliente);
GO

alter table DBAS.canjes add constraint fk_canje_producto
	foreign key (id_producto) references DBAS.productos (id_producto);
GO

alter table DBAS.periodosFueraDeServicio add constraint fk_periodos_aeronave
	foreign key (matricula_aeronave) references DBAS.aeronaves (matricula_aeronave);	
GO

alter table DBAS.rolesPorFuncionalidad add constraint fk_rolesPorFuncionalidad_rol
	foreign key (id_rol) references DBAS.roles (id_rol);
GO

alter table DBAS.rolesPorFuncionalidad add constraint fk_rolesPorFuncionalidad_funcionalidad
	foreign key (id_funcionalidad) references DBAS.funcionalidades (id_funcionalidad);
GO

alter table DBAS.usuariosPorRol add constraint fk_usuariosPorRol_usuarios
	foreign key (id_usuario) references DBAS.usuarios (id_usuario);
GO

alter table DBAS.usuariosPorRol add constraint fk_usuariosPorRol_rol
	foreign key (id_rol) references DBAS.roles (id_rol);
GO

alter table DBAS.serviciosPorRutas add constraint fk_serviciosPorRutas_ruta
	foreign key(codigo_ruta) references DBAS.rutas (codigo_ruta);
GO

alter table DBAS.serviciosPorRutas add constraint fk_serviciosPorRutas_servicio
	foreign key(id_servicio) references DBAS.servicios (id_servicio);
GO

/* -- Fecha del sistema -- */

INSERT INTO DBAS.date_time(GET_DATE)
VALUES(GETDATE())
GO

CREATE PROCEDURE DBAS.cambiarFechaDelSistema(@fecha_sistema datetime)
AS
BEGIN
	
	-- Establezco la nueva fecha actual del sistema
	UPDATE DBAS.date_time SET GET_DATE = @fecha_sistema

END;
GO

/* -- Migracion -- */

--Tablas temporales para la migracion

--Creo una tabla temporal que va a ser de ayuda para la migracion de los pasajes y asi utilizar menos tabla y ganar tiempo de busqueda de las ids
CREATE TABLE DBAS.#temporalViajesConRutas(id_viaj bigint, codigo_rut bigint, nom_ruta_orig varchar(100), nom_ruta_dest varchar(100), fecha_salida datetime, fecha_llegada datetime, matricula_aeronave varchar(100));
GO

--Creo una tabla temporal con el fin de utilizarla como ayuda para la migracion de los pasajes y asi buscar menos ids y mejorar el tiempo de migracion
CREATE TABLE DBAS.#temporalPasajesDeClientes(id_cliente bigint, fecha_llegada datetime, fecha_salida datetime, ciudad_origen varchar(100), ciudad_destino varchar(100), Pasaje_Codigo bigint, Pasaje_Precio float(24), Pasaje_FechaCompra datetime, Paquete_Codigo bigint, Paquete_Precio float(24), Paquete_FechaCompra datetime, Paquete_KG float(24), Butaca_Nro smallint, Butaca_Piso tinyint, Aeronave_Matricula varchar(100));
GO

--Creacion de triggers para la migracion

--Creo un trigger que sirve para asociar el id de un cliente con el de la persona y lo ordeno por su id para 
--asegurarme de que tanto el id del cliente como el de la persona sean identicos para asi utilizar 
--el id de la persona sin buscarlo en la tabla clientes para la migracion
CREATE TRIGGER DBAS.migrarClientesEnPersonaTrigger ON DBAS.personas
AFTER INSERT
AS
BEGIN
	INSERT INTO DBAS.clientes(id_persona)
	SELECT id_persona FROM inserted
	ORDER BY id_persona
END;
GO

--Creo un trigger en persona para asi una vez insertadas las personas utilizar sus id para la relacionar los pasajes de la maestra con el id del cliente que lo posee
CREATE TRIGGER DBAS.temporalPasajesDeClientestrigger ON DBAS.personas
AFTER INSERT
AS
BEGIN
	INSERT INTO #temporalPasajesDeClientes(id_cliente, fecha_llegada, fecha_salida, ciudad_origen, ciudad_destino, Pasaje_Codigo, Pasaje_Precio, Pasaje_FechaCompra, Paquete_Codigo, Paquete_Precio, Paquete_FechaCompra, Paquete_KG, Butaca_Nro, Butaca_Piso, Aeronave_Matricula)
	SELECT tablaPersona.id_persona, tablaMaestra.FechaLLegada, tablaMaestra.FechaSalida,  SUBSTRING(tablaMaestra.Ruta_Ciudad_Origen,2,LEN(tablaMaestra.Ruta_Ciudad_Origen)-1) , SUBSTRING(tablaMaestra.Ruta_Ciudad_Destino,2,LEN(tablaMaestra.Ruta_Ciudad_Destino)-1), tablaMaestra.Pasaje_Codigo, tablaMaestra.Pasaje_Precio, tablaMaestra.Pasaje_FechaCompra, tablaMaestra.Paquete_Codigo, tablaMaestra.Paquete_Precio, tablaMaestra.Paquete_FechaCompra, tablaMaestra.Paquete_KG, tablaMaestra.Butaca_Nro, tablaMaestra.Butaca_Piso, tablaMaestra.Aeronave_Matricula 
	FROM ((SELECT id_persona, dni_persona, nombre_persona, apellido_persona FROM inserted) tablaPersona
	JOIN (SELECT Cli_Dni, Cli_Apellido, Cli_Nombre, Pasaje_Codigo, Pasaje_Precio, Pasaje_FechaCompra, Paquete_Codigo, Paquete_Precio, Paquete_FechaCompra, Paquete_KG, Butaca_Nro, Butaca_Piso, FechaSalida, FechaLLegada, Ruta_Ciudad_Origen, Ruta_Ciudad_Destino, Aeronave_Matricula FROM gd_esquema.Maestra) tablaMaestra
	ON (tablaPersona.dni_persona = tablaMaestra.Cli_Dni AND tablaPersona.nombre_persona = tablaMaestra.Cli_Nombre AND tablaPersona.apellido_persona = tablaMaestra.Cli_Apellido))
END;
GO

--Creo un trigger para la insercion de los valores en la tabla temporal una vez que se insertaron los viajes
CREATE TRIGGER DBAS.migrarDatosATemporalTrigger ON DBAS.viajes
AFTER INSERT
AS
BEGIN
	
	INSERT INTO #temporalViajesConRutas(id_viaj, codigo_rut, nom_ruta_orig, nom_ruta_dest, fecha_salida, fecha_llegada, matricula_aeronave)
	SELECT tablaViajes.id_viaje, tablaRutas.codigo_ruta, tablaCiudadOrig.nombre_ciudad, tablaCiudadDest.nombre_ciudad, tablaViajes.fecha_salida, tablaViajes.fecha_llegada, tablaViajes.matricula_aeronave 
	FROM ((SELECT id_viaje, fecha_salida, fecha_llegada, codigo_ruta, matricula_aeronave FROM inserted) tablaViajes
		JOIN (SELECT codigo_ruta, ciudad_origen_id, ciudad_destino_id FROM DBAS.rutas) tablaRutas
		ON (tablaViajes.codigo_ruta = tablaRutas.codigo_ruta)
			JOIN DBAS.ciudades tablaCiudadOrig ON (tablaRutas.ciudad_origen_id = tablaCiudadOrig.id_ciudad)
			JOIN DBAS.ciudades tablaCiudadDest ON (tablaRutas.ciudad_destino_id = tablaCiudadDest.id_ciudad))
END;
GO

--Creo stored procedures para la migracion

CREATE PROCEDURE DBAS.migracionFabricantes
AS
BEGIN

	--Se migran los fabricante de la tabla Maestra
	INSERT INTO DBAS.fabricantes(nombre_fabricante)
	SELECT DISTINCT Aeronave_Fabricante 
	FROM gd_esquema.Maestra

END;
GO

CREATE PROCEDURE DBAS.migracionCiudades
AS
BEGIN
	
	--Se migran las ciudades destino y origen quedando solo las que no se repiten, además se elimina el espacio que hay al principio de cada ciudad
	INSERT INTO DBAS.ciudades(nombre_ciudad)
	SELECT DISTINCT SUBSTRING(Ruta_Ciudad_Origen,2,LEN(Ruta_Ciudad_Origen)+7) FROM gd_esquema.Maestra UNION SELECT DISTINCT SUBSTRING(Ruta_Ciudad_Destino,2,LEN(Ruta_Ciudad_Origen)+7) FROM gd_esquema.Maestra

END;
GO

CREATE PROCEDURE DBAS.migracionServicios
AS
BEGIN
	--Se migran los servivios de la tabla maestra y el porcentaje de arancel de cada uno
	INSERT INTO DBAS.servicios(tipo_servicio, porcentaje_arancel)
	SELECT Tipo_Servicio, ROUND(SUM(Pasaje_Precio/Ruta_Precio_BasePasaje)/COUNT(Pasaje_Codigo),2) FROM gd_esquema.Maestra 
	WHERE Pasaje_Codigo != 0
	GROUP BY Tipo_Servicio
END;
GO

CREATE PROCEDURE DBAS.migracionRutas
AS
BEGIN
	DECLARE @id_ciudad_original bigint
	DECLARE @id_ciudad_destino bigint
	DECLARE @precio_KG float(24)
	DECLARE @precio_pasaje float(24)
	DECLARE @id_servicio bigint
	DECLARE @id_ruta bigint

	--Obtengo todas las rutas de la base maestra y obtengo las id de las ciudades y servicios ya migrados
	DECLARE migrarRutasConServicios CURSOR FOR
	SELECT DISTINCT tablaCiudades_orig.id_ciudad, tablaCiudades_dest.id_ciudad, tablaAux2.Ruta_Precio_BaseKG, tablaAux1.Ruta_Precio_BasePasaje, tablaServicios.id_servicio
			FROM ((SELECT DISTINCT Ruta_Codigo, Ruta_Ciudad_Origen, Ruta_Ciudad_Destino,Ruta_Precio_BasePasaje, Tipo_Servicio FROM gd_esquema.Maestra WHERE Ruta_Precio_BasePasaje > 0.00) tablaAux1
				JOIN (SELECT DISTINCT Ruta_Codigo,Ruta_Ciudad_Origen, Ruta_Ciudad_Destino,Ruta_Precio_BaseKG, Tipo_Servicio FROM gd_esquema.Maestra WHERE Ruta_Precio_BASEKG > 0.00) tablaAux2
					ON (tablaAux1.Ruta_Ciudad_Origen = tablaAux2.Ruta_Ciudad_Origen AND tablaAux1.Ruta_Ciudad_Destino = tablaAux2.Ruta_Ciudad_Destino)
					JOIN DBAS.ciudades tablaCiudades_dest ON ( SUBSTRING(tablaAux1.Ruta_Ciudad_Destino,2,LEN(tablaAux1.Ruta_Ciudad_Destino)-1) = tablaCiudades_dest.nombre_ciudad)
					JOIN DBAS.ciudades  tablaCiudades_orig ON ( SUBSTRING(tablaAux1.Ruta_Ciudad_Origen,2,LEN(tablaAux1.Ruta_Ciudad_Origen)-1) = tablaCiudades_orig.nombre_ciudad)
					JOIN DBAS.servicios tablaServicios ON (tablaAux1.Tipo_Servicio = tablaServicios.tipo_servicio))

	OPEN migrarRutasConServicios

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM migrarRutasConServicios
	INTO @id_ciudad_original, @id_ciudad_destino, @precio_KG, @precio_pasaje, @id_servicio

	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		INSERT INTO DBAS.rutas(ciudad_origen_id, ciudad_destino_id, precio_base_por_KG, precio_base_por_pasaje)
		VALUES(@id_ciudad_original, @id_ciudad_destino, @precio_KG, @precio_pasaje)

		SET @id_ruta = SCOPE_IDENTITY()

		INSERT INTO DBAS.serviciosPorRutas(codigo_ruta, id_servicio)
		VALUES(@id_ruta, @id_servicio)

		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM migrarRutasConServicios
		INTO @id_ciudad_original, @id_ciudad_destino, @precio_KG, @precio_pasaje, @id_servicio

	END 
	
	CLOSE migrarRutasConServicios
	DEALLOCATE migrarRutasConServicios

END;
GO

/*
-- sirve para saber si hay consistencia con el tipo de servicio de la aeronave
SELECT DISTINCT aux1.Aeronave_matricula, aux1.Aeronave_KG_Disponibles, aux1.Aeronave_Fabricante, aux1.Tipo_Servicio 
FROM ((SELECT Aeronave_matricula, Aeronave_KG_Disponibles, Aeronave_Fabricante, Tipo_Servicio FROM gd_esquema.Maestra) aux1 JOIN (SELECT Aeronave_matricula, Aeronave_KG_Disponibles, Aeronave_Fabricante, Tipo_Servicio FROM gd_esquema.Maestra) aux2 
ON (aux1.Aeronave_Matricula = aux2.Aeronave_Matricula AND aux1.Tipo_Servicio != aux2.Tipo_Servicio)) 

-- sirve para saber si hay consistencia con kg disponibles
SELECT DISTINCT aux1.Aeronave_matricula, aux1.Aeronave_KG_Disponibles, aux1.Aeronave_Fabricante, aux1.Tipo_Servicio 
FROM ((SELECT Aeronave_matricula, Aeronave_KG_Disponibles, Aeronave_Fabricante, Tipo_Servicio FROM gd_esquema.Maestra) aux1 JOIN (SELECT Aeronave_matricula, Aeronave_KG_Disponibles, Aeronave_Fabricante, Tipo_Servicio FROM gd_esquema.Maestra) aux2 
ON (aux1.Aeronave_Matricula = aux2.Aeronave_Matricula AND aux1.Aeronave_KG_Disponibles != aux2.Aeronave_KG_Disponibles)) 
*/

CREATE PROCEDURE DBAS.migracionAeronaves
AS
BEGIN

	--Migro las aeronaves de la tabla Maestra, utilizando las tablas fabricantes y servicios para obtener sus ids
	INSERT INTO DBAS.aeronaves(matricula_aeronave, modelo_aeronave, kg_disponible_encomienda, id_fabricante, id_servicio)
	SELECT tablaAux.Aeronave_Matricula, tablaAux.Aeronave_Modelo, tablaAux.Aeronave_KG_Disponibles, tablaFab.id_fabricante, tablaServ.id_servicio
	FROM ((SELECT DISTINCT Aeronave_matricula, Aeronave_KG_Disponibles, Aeronave_Fabricante, Aeronave_Modelo, Tipo_Servicio FROM gd_esquema.Maestra) tablaAux
		JOIN DBAS.fabricantes tablaFab ON (tablaFab.nombre_fabricante = tablaAux.Aeronave_Fabricante)
			JOIN DBAS.servicios tablaServ ON (tablaServ.tipo_servicio = tablaAux.Tipo_Servicio))
END;
GO

CREATE PROCEDURE DBAS.migracionViajes
AS
BEGIN

	--Inserto la cantidad de viajes de la tabla maestra
	INSERT INTO DBAS.viajes (fecha_salida,fecha_llegada_estimada,fecha_llegada,matricula_aeronave,codigo_ruta)
	SELECT tablaAux.FechaSalida, tablaAux.Fecha_LLegada_Estimada, tablaAux.FechaLLegada, tablaAux.Aeronave_Matricula, tablaRutas.codigo_ruta
	FROM ((SELECT DISTINCT FechaSalida, Fecha_LLegada_Estimada, FechaLLegada, Aeronave_Matricula, Ruta_Ciudad_Origen, Ruta_Ciudad_Destino FROM gd_esquema.Maestra) tablaAux 
		JOIN DBAS.ciudades tablaciudad_orig ON (tablaciudad_orig.nombre_ciudad= SUBSTRING(tablaAux.Ruta_Ciudad_Origen,2,LEN(tablaAux.Ruta_Ciudad_Origen)-1) )
			JOIN DBAS.ciudades tablaciudad_dest ON (tablaciudad_dest.nombre_ciudad =   SUBSTRING(tablaAux.Ruta_Ciudad_Destino,2,LEN(tablaAux.Ruta_Ciudad_Destino)-1) )
				JOIN DBAS.rutas tablaRutas ON (tablaRutas.ciudad_origen_id = tablaciudad_orig.id_ciudad AND tablaRutas.ciudad_destino_id = tablaciudad_dest.id_ciudad))
END;
GO

CREATE PROCEDURE DBAS.migracionButacas
AS
BEGIN

	--Inserto las butacas de cada avion de la tabla maestra
	INSERT INTO DBAS.butacas (numero_butaca, tipo_butaca, piso_butaca, matricula_aeronave)
	SELECT DISTINCT Butaca_Nro, Butaca_Tipo, Butaca_Piso, Aeronave_Matricula FROM gd_esquema.Maestra

END;
GO

CREATE PROCEDURE DBAS.migracionClientes
AS
BEGIN

	--Migro las personas de la tabla maestra
	INSERT INTO DBAS.personas(dni_persona, nombre_persona, apellido_persona, direccion_persona, telefono_persona, mail_persona, fecha_nacimiento)
	SELECT DISTINCT Cli_Dni, Cli_Nombre, Cli_Apellido, Cli_Dir, Cli_Telefono, Cli_Mail, Cli_Fecha_Nac FROM gd_esquema.Maestra

END;
GO

CREATE PROCEDURE DBAS.migracionPasajes
AS
BEGIN

	--Activo la insercion en la variable identity de la tabla
	SET IDENTITY_INSERT DBAS.pasajes ON

	--Inserto los valores de las las tablas temporales que solo tengan pasajes y no encomiendas
	INSERT INTO DBAS.pasajes(codigo_pasaje, id_cliente, precio_pasaje, fecha_compra_pasaje, id_viaje, id_butaca)
	SELECT DISTINCT tablaTemporalPasajes.Pasaje_Codigo, tablaTemporalPasajes.id_cliente, tablaTemporalPasajes.Pasaje_Precio, tablaTemporalPasajes.Pasaje_FechaCompra, tablaTemporalViajes.id_viaj, tablaButacas.id_butaca 
	FROM ((SELECT id_cliente, fecha_llegada, fecha_salida, ciudad_origen, ciudad_destino, Pasaje_Codigo, Pasaje_Precio, Pasaje_FechaCompra, Paquete_Codigo, Paquete_Precio, Paquete_FechaCompra, Paquete_KG, Butaca_Nro, Butaca_Piso, Aeronave_Matricula FROM #temporalPasajesDeClientes WHERE Butaca_Piso != 0) tablaTemporalPasajes
		JOIN DBAS.butacas tablaButacas ON (tablaTemporalPasajes.Aeronave_Matricula = tablaButacas.matricula_aeronave AND tablaTemporalPasajes.Butaca_Nro = tablaButacas.numero_butaca AND tablaTemporalPasajes.Butaca_Piso = tablaButacas.piso_butaca)
		JOIN #temporalViajesConRutas tablaTemporalViajes ON (tablaTemporalViajes.nom_ruta_orig = tablaTemporalPasajes.ciudad_origen AND tablaTemporalViajes.nom_ruta_dest = tablaTemporalPasajes.ciudad_destino AND tablaTemporalViajes.fecha_salida = tablaTemporalPasajes.fecha_salida AND tablaTemporalViajes.fecha_llegada = tablaTemporalPasajes.fecha_llegada AND tablaTemporalPasajes.Aeronave_Matricula = tablaTemporalViajes.matricula_aeronave))

	--Activo el identity para que se genere automaticamente nuevamente
	SET IDENTITY_INSERT DBAS.pasajes OFF

END;
GO

CREATE PROCEDURE DBAS.migracionEncomiendas
AS
BEGIN

	--Activo la insercion en la variable identity de la tabla
	SET IDENTITY_INSERT DBAS.encomiendas ON

	--Inserto los valores de las las tablas temporales que solo tengan encomiendas y no pasajes
	INSERT INTO DBAS.encomiendas(codigo_encomienda, id_cliente, encomienda_cliente_KG, precio_encomienda, fecha_compra_encomienda, id_viaje)
	SELECT DISTINCT tablaTemporalPasajes.Paquete_Codigo, tablaTemporalPasajes.id_cliente, tablaTemporalPasajes.Paquete_KG, tablaTemporalPasajes.Paquete_Precio, tablaTemporalPasajes.Paquete_FechaCompra, tablaTemporalViajes.id_viaj
	FROM ((SELECT id_cliente, fecha_llegada, fecha_salida, ciudad_origen, ciudad_destino, Pasaje_Codigo, Pasaje_Precio, Pasaje_FechaCompra, Paquete_Codigo, Paquete_Precio, Paquete_FechaCompra, Paquete_KG, Butaca_Nro, Butaca_Piso, Aeronave_Matricula FROM #temporalPasajesDeClientes WHERE Butaca_Piso = 0) tablaTemporalPasajes
		JOIN #temporalViajesConRutas tablaTemporalViajes ON (tablaTemporalViajes.nom_ruta_orig = tablaTemporalPasajes.ciudad_origen AND tablaTemporalViajes.nom_ruta_dest = tablaTemporalPasajes.ciudad_destino AND tablaTemporalViajes.fecha_salida = tablaTemporalPasajes.fecha_salida AND tablaTemporalViajes.fecha_llegada = tablaTemporalPasajes.fecha_llegada AND tablaTemporalPasajes.Aeronave_Matricula = tablaTemporalViajes.matricula_aeronave))


	--Activo el identity para que se genere automaticamente nuevamente
	SET IDENTITY_INSERT DBAS.encomiendas OFF

END;
GO

--Ejecuto los stored procedures
EXECUTE DBAS.migracionFabricantes
EXECUTE DBAS.migracionCiudades
EXECUTE DBAS.migracionServicios
EXECUTE DBAS.migracionRutas
EXECUTE DBAS.migracionAeronaves
EXECUTE DBAS.migracionViajes
EXECUTE DBAS.migracionButacas
EXECUTE DBAS.migracionClientes
EXECUTE DBAS.migracionPasajes
EXECUTE DBAS.migracionEncomiendas
GO

--Elimino las tablas temporales de la migracion

DROP TABLE #temporalPasajesDeClientes
GO

DROP TABLE #temporalViajesConRutas
GO

--Elimino los triggers de la migracion

DROP TRIGGER DBAS.temporalPasajesDeClientestrigger
GO

DROP TRIGGER DBAS.migrarDatosATemporalTrigger
GO

DROP TRIGGER DBAS.migrarClientesEnPersonaTrigger
GO

/* Roles y funcionalidades */

-- Se agregan las funcionalidades
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('ABM de Rol');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Registro de Usuario');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('ABM de Ciudades');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('ABM de Ruta Aerea');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('ABM de Aeronaves');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Generar Viaje'); 
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Registro de llegada Destino');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Compra de Pasaje/Encomienda');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Cancelación/Devolución de pasaje y/o encomienda');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Consulta de millas de pasajero frecuente');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Canje de millas de pasajero frecuente');
INSERT INTO DBAS.funcionalidades (descripcion) VALUES ('Listado Estadístico');
GO

-- insercion del rol administrador
INSERT INTO DBAS.roles(nombre_rol) VALUES('Administrador General');
GO

-- Se agregan funcionalidades al rol administrador
INSERT INTO DBAS.rolesPorFuncionalidad(id_rol, id_funcionalidad)
select tablaRol.id_rol, tablaFuncionalidad.id_funcionalidad from DBAS.roles  tablaRol, DBAS.funcionalidades tablaFuncionalidad
where tablaRol.nombre_rol = 'Administrador General'
GO

-- Se agregan usuarios administradores
INSERT INTO DBAS.personas(dni_persona,apellido_persona,nombre_persona)
VALUES(99999999,'Admin','Admin')

DECLARE @id_p bigint
SET @id_p = SCOPE_IDENTITY()

-- Se inserta el usuario admin, password w23e
INSERT INTO DBAS.usuarios(id_usuario,username,password)
VALUES (@id_p,'admin','e6b87050bfcb8143fcb8db0170a4dc9ed00d904ddd3e2a4ad1b1e8dc0fdc9be7')
GO

-- Se le asigna el rol administrador general al usuario admin
INSERT INTO DBAS.usuariosPorRol(id_usuario, id_rol)
SELECT tablaUsuarios.id_usuario, tablaRoles.id_rol FROM DBAS.usuarios tablaUsuarios, DBAS.roles tablaRoles
WHERE tablaRoles.nombre_rol = 'Administrador General' and tablaUsuarios.username = 'admin'
GO

-- Inserto productos
INSERT INTO DBAS.productos(valor_en_milas,nombre_producto,stock)
VALUES (2500,'cafetera',50)
GO

INSERT INTO DBAS.productos(valor_en_milas,nombre_producto,stock)
VALUES (300,'cuaderno',400)
GO

INSERT INTO DBAS.productos(valor_en_milas,nombre_producto,stock)
VALUES (1200,'exprimidora',50)
GO

INSERT INTO DBAS.productos(valor_en_milas,nombre_producto,stock)
VALUES (550,'taza',300)
GO

INSERT INTO DBAS.productos(valor_en_milas,nombre_producto,stock)
VALUES (15000,'televisor',1)
GO

INSERT INTO DBAS.tiposTarjeta(descripcion_tipo, cuotas)
VALUES ('MasterCard', 6)
GO

INSERT INTO DBAS.tiposTarjeta(descripcion_tipo, cuotas)
VALUES ('Visa', 24)
GO

INSERT INTO DBAS.tiposTarjeta(descripcion_tipo, cuotas)
VALUES ('American Express', 12)
GO

/* -- Calculo de millas -- */

CREATE FUNCTION DBAS.preciosPasajes(@dni_persona bigint) 
RETURNS @pasajes TABLE (ciudad_origen varchar(100), ciudad_destino varchar(100), fecha_llegada datetime, precio_base_por_pasaje float(24), porcentaje_arancel float(24),precio_pasaje float(24))
AS
BEGIN
	INSERT INTO @pasajes
	SELECT c1.nombre_ciudad, c2.nombre_ciudad, tablaViajes.fecha_llegada, tablaRutas.precio_base_por_pasaje, tablaServicios.porcentaje_arancel, precio_base_por_pasaje*porcentaje_arancel
	FROM DBAS.pasajes tablaPasajes, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.personas tablaPersonas, DBAS.clientes tablaClientes, DBAS.serviciosPorRutas tablaServiciosPorRutas, DBAS.servicios tablaServicios, DBAS.ciudades c1,  DBAS.ciudades c2
	WHERE tablaClientes.id_cliente = tablaPasajes.id_cliente AND tablaPasajes.id_cliente = tablaPersonas.id_persona 
	AND tablaPersonas.dni_persona = @dni_persona AND tablaPasajes.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta
	AND tablaRutas.codigo_ruta = tablaServiciosPorRutas.codigo_ruta AND tablaServiciosPorRutas.id_servicio = tablaServicios.id_servicio 
	AND tablaViajes.fecha_llegada IS NOT NULL AND tablaRutas.ciudad_origen_id = c1.id_ciudad AND tablaRutas.ciudad_destino_id = c2.id_ciudad
	RETURN
END;
GO

CREATE FUNCTION DBAS.preciosEncomiendas(@dni_persona bigint) 
RETURNS @encomiendas TABLE (ciudad_origen varchar(100), ciudad_destino varchar(100), fecha_llegada datetime, precio_base_por_kg float(24), porcentaje_arancel float(24),precio_encomienda float(24))
AS
BEGIN
	INSERT INTO @encomiendas
	SELECT c1.nombre_ciudad, c2.nombre_ciudad, tablaViajes.fecha_llegada, tablaRutas.precio_base_por_KG, tablaServicios.porcentaje_arancel, precio_base_por_KG*encomienda_cliente_KG*porcentaje_arancel
	FROM DBAS.encomiendas tablaEncomiendas, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.personas tablaPersonas, DBAS.clientes tablaClientes, DBAS.serviciosPorRutas tablaServiciosPorRutas, DBAS.servicios tablaServicios, DBAS.ciudades c1,  DBAS.ciudades c2
	WHERE tablaClientes.id_cliente = tablaEncomiendas.id_cliente AND tablaEncomiendas.id_cliente = tablaPersonas.id_persona 
	AND tablaPersonas.dni_persona = @dni_persona AND tablaEncomiendas.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta
	AND tablaRutas.codigo_ruta = tablaServiciosPorRutas.codigo_ruta AND tablaServiciosPorRutas.id_servicio = tablaServicios.id_servicio AND tablaViajes.fecha_llegada IS NOT NULL
	AND tablaRutas.ciudad_origen_id = c1.id_ciudad AND tablaRutas.ciudad_destino_id = c2.id_ciudad
	RETURN
END;
GO

CREATE FUNCTION DBAS.historialMillas(@dni_persona bigint)
RETURNS @millas TABLE (ciudad_origen varchar(100), ciudad_destino varchar(100), cantidad_millas bigint, fecha_obtencion_millas datetime, tipo varchar(20))
AS
BEGIN
	INSERT INTO @millas
	SELECT ciudad_origen, ciudad_destino, precio_pasaje/10, fecha_llegada,'Pasaje' FROM DBAS.preciosPasajes(@dni_persona)
	INSERT INTO @millas
	SELECT ciudad_origen, ciudad_destino, precio_encomienda/10, fecha_llegada,'Encomienda' FROM DBAS.preciosEncomiendas(@dni_persona)
	RETURN
END;
GO


CREATE VIEW DBAS.millasPorPasajes AS
SELECT id_cliente, fecha_llegada, CAST((precio_base_por_pasaje*porcentaje_arancel)/10 AS bigint) as millas FROM DBAS.pasajes pasajes, DBAS.viajes viajes, DBAS.rutas rutas, DBAS.serviciosPorRutas serviciosPorRutas, DBAS.servicios servicios
WHERE pasajes.id_viaje = viajes.id_viaje AND viajes.codigo_ruta = rutas.codigo_ruta
AND serviciosPorRutas.codigo_ruta = rutas.codigo_ruta AND serviciosPorRutas.id_servicio = servicios.id_servicio
GO

CREATE VIEW DBAS.millasPorEncomiendas AS
SELECT id_cliente, fecha_llegada,CAST((precio_base_por_KG*encomienda_cliente_KG*porcentaje_arancel)/10 AS bigint) as millas FROM DBAS.encomiendas encomiendas, DBAS.viajes viajes, DBAS.rutas rutas, DBAS.serviciosPorRutas serviciosPorRutas, DBAS.servicios servicios
WHERE encomiendas.id_viaje = viajes.id_viaje AND viajes.codigo_ruta = rutas.codigo_ruta
AND serviciosPorRutas.codigo_ruta = rutas.codigo_ruta AND serviciosPorRutas.id_servicio = servicios.id_servicio
GO


CREATE FUNCTION DBAS.millasVigentes(@dni_persona bigint)
RETURNS bigint
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	RETURN ((SELECT SUM(cantidad_millas) FROM DBAS.historialMillas(@dni_persona)
	WHERE DATEDIFF(day,fecha_obtencion_millas,@GET_DATE) <= 365) -
	 ( ISNULL((SELECT SUM(millas_usadas) FROM DBAS.canjes tablaCanjes, DBAS.clientes tablaClientes, DBAS.personas tablaPersonas
	WHERE tablaCanjes.id_cliente = tablaClientes.id_cliente AND tablaClientes.id_persona = tablaPersonas.id_persona
	AND tablaPersonas.dni_persona = @dni_persona AND DATEDIFF(day,fecha_canje,@GET_DATE) <= 365
	GROUP BY id_canje),0)))
END;
GO



CREATE FUNCTION DBAS.millasAcumuladasEntre(@fecha_desde datetime, @fecha_hasta datetime)
RETURNS @millasAcumuladas TABLE (id_cliente bigint,millas bigint)
AS
BEGIN
	INSERT INTO @millasAcumuladas
	SELECT tabla1.id_cliente,millas_p + millas_e as millas FROM (

	(SELECT id_cliente,ISNULL(SUM(millas),0) as millas_p FROM DBAS.millasPorPasajes millasPasajes
		WHERE millasPasajes.fecha_llegada >= @fecha_desde AND millasPasajes.fecha_llegada < @fecha_hasta
		GROUP BY id_cliente) tabla1
	JOIN
	(SELECT id_cliente,ISNULL(SUM(millas),0) as millas_e FROM DBAS.millasPorEncomiendas millasEncomiendas
		WHERE millasEncomiendas.fecha_llegada >= @fecha_desde AND millasEncomiendas.fecha_llegada < @fecha_hasta
		GROUP BY id_cliente) tabla2
	
	ON (tabla1.id_cliente= tabla2.id_cliente)
	)
	RETURN
END;
GO


CREATE PROCEDURE DBAS.canjeProducto(@id_cliente bigint, @id_producto bigint, @cantidadACanjear bigint)
AS
BEGIN
	DECLARE @dni_persona bigint
	DECLARE @millas_vigentes bigint
	DECLARE @valor_unitario_en_millas bigint
	DECLARE @mensaje_error varchar(100)
	DECLARE @valor_total_en_millas bigint
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	SET @dni_persona = (SELECT dni_persona FROM DBAS.personas tablaPersonas, DBAS.clientes tablaClientes 
	WHERE tablaClientes.id_cliente = @id_cliente AND tablaPersonas.id_persona = tablaClientes.id_persona)

	SET @millas_vigentes = DBAS.millasVigentes(@dni_persona)

	SET @valor_unitario_en_millas = (SELECT valor_en_milas FROM DBAS.productos WHERE id_producto = @id_producto)

	SET @valor_total_en_millas = @valor_unitario_en_millas * @cantidadACanjear

	IF(@valor_total_en_millas > @millas_vigentes)
	BEGIN
		
		SET @mensaje_error = 'No posee millas suficientes para canjear este producto'
		RAISERROR(@mensaje_error, 12, 1)

	END
	ELSE
	BEGIN
		INSERT INTO DBAS.canjes(id_cliente,fecha_canje,cantidad_producto,millas_usadas,id_producto)
		VALUES (@id_cliente,@GET_DATE,@cantidadACanjear,@valor_total_en_millas,@id_producto)
	END

END;
GO


/*-- TOP 5 -- */

CREATE FUNCTION DBAS.Top5DeLosDestinosConMasPasajesComprados(@semestreDelAnio tinyint, @anio integer)
RETURNS @TOP5 TABLE ( ciudad_origen varchar(100), ciudad_destino varchar(100), pasajes_comprados bigint)
AS
BEGIN
	
	-- Me pasan por parametro el año y lo concateno con una fecha generica que sirve para indicar luego a que semestre pertenece
	DECLARE @anioDelSemestre datetime
	SET @anioDelSemestre = convert(datetime, concat(@anio, '0701 00:00:00.000'))

	IF (@semestreDelAnio = 1)
	BEGIN
		
		-- Devuelvo una tabla con los pasajes más comprados en base a las ciudades de origen y destino en el primer semestre
		INSERT INTO @TOP5(ciudad_origen, ciudad_destino, pasajes_comprados)
		SELECT TOP 5 tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad, COUNT(tablaPasajes.codigo_pasaje) as pasajes_comprados FROM DBAS.pasajes tablaPasajes, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades1, DBAS.ciudades tablaCiudades2
		WHERE tablaPasajes.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta AND tablaCiudades1.id_ciudad = tablaRutas.ciudad_origen_id AND tablaCiudades2.id_ciudad = tablaRutas.ciudad_destino_id
			AND tablaPasajes.fecha_compra_pasaje <  @anioDelSemestre AND DATEPART(year,tablaPasajes.fecha_compra_pasaje) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad
		ORDER BY pasajes_comprados DESC

		
	END
	ELSE
		BEGIN

			-- Devuelvo una tabla con los pasajes más comprados en base a las ciudades de origen y destino en el segundo semestre
			INSERT INTO @TOP5(ciudad_origen, ciudad_destino, pasajes_comprados)
			SELECT TOP 5 tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad, COUNT(tablaPasajes.codigo_pasaje) as pasajes_comprados FROM DBAS.pasajes tablaPasajes, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades1, DBAS.ciudades tablaCiudades2
			WHERE tablaPasajes.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta AND tablaCiudades1.id_ciudad = tablaRutas.ciudad_origen_id AND tablaCiudades2.id_ciudad = tablaRutas.ciudad_destino_id
			AND tablaPasajes.fecha_compra_pasaje >=  @anioDelSemestre AND DATEPART(year,tablaPasajes.fecha_compra_pasaje) = DATEPART(year,@anioDelSemestre)
			GROUP BY tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad
			ORDER BY pasajes_comprados DESC

		END

	RETURN
END;	
GO


CREATE FUNCTION DBAS.Top5DeLosDestinosConMasPasajesCancelados(@semestreDelAnio tinyint, @anio integer)
RETURNS @TOP5 TABLE ( ciudad_origen varchar(100), ciudad_destino varchar(100), pasajes_cancelados bigint)
AS
BEGIN
	
	-- Me pasan por parametro el año y lo concateno con una fecha generica que sirve para indicar luego a que semestre pertenece
	DECLARE @anioDelSemestre datetime
	SET @anioDelSemestre = convert(datetime, concat(@anio, '0701 00:00:00.000'))

	IF (@semestreDelAnio = 1)
	BEGIN
		
		-- Devuelvo una tabla con los pasajes más cancelados en base a las ciudades de origen y destino en el primer semestre
		INSERT INTO @TOP5(ciudad_origen, ciudad_destino, pasajes_cancelados)
		SELECT TOP 5 tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad, COUNT(tablaPasajes.codigo_pasaje) as pasajes_cancelados 
		FROM DBAS.pasajes tablaPasajes, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades1, DBAS.ciudades tablaCiudades2
		WHERE tablaPasajes.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta AND tablaPasajes.id_cancelacion IS NOT NULL
		AND tablaCiudades1.id_ciudad = tablaRutas.ciudad_origen_id AND tablaCiudades2.id_ciudad = tablaRutas.ciudad_destino_id
		AND tablaPasajes.fecha_compra_pasaje <  @anioDelSemestre AND DATEPART(year,tablaPasajes.fecha_compra_pasaje) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad
		ORDER BY pasajes_cancelados DESC

		
	END
	ELSE
		BEGIN
			
			-- Devuelvo una tabla con los pasajes más cancelados en base a las ciudades de origen y destino en el primer semestre
			INSERT INTO @TOP5(ciudad_origen, ciudad_destino, pasajes_cancelados)
			SELECT TOP 5 tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad, COUNT(tablaPasajes.codigo_pasaje) as pasajes_cancelados
			FROM DBAS.pasajes tablaPasajes, DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades1, DBAS.ciudades tablaCiudades2
			WHERE tablaPasajes.id_viaje = tablaViajes.id_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta  AND tablaPasajes.id_cancelacion IS NOT NULL
			AND tablaCiudades1.id_ciudad = tablaRutas.ciudad_origen_id AND tablaCiudades2.id_ciudad = tablaRutas.ciudad_destino_id
			AND tablaPasajes.fecha_compra_pasaje >=  @anioDelSemestre AND DATEPART(year,tablaPasajes.fecha_compra_pasaje) = DATEPART(year,@anioDelSemestre)
			GROUP BY tablaCiudades1.nombre_ciudad, tablaCiudades2.nombre_ciudad
			ORDER BY pasajes_cancelados DESC

		END

	RETURN
END;	
GO

CREATE FUNCTION DBAS.aeronaves_dias_fuera_de_servicio(@semestreDelAnio tinyint, @anio integer)
RETURNS @aeronaves_dias_fuera_de_servicio TABLE ( aeronave varchar(100), dias_fuera_de_servicio bigint)
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Me pasan por parametro el año y lo concateno con una fecha generica que sirve para indicar luego a que semestre pertenece
	DECLARE @anioDelSemestre datetime
	SET @anioDelSemestre = convert(datetime, concat(@anio, '0701 00:00:00.000'))

	IF (@semestreDelAnio = 1)
	BEGIN
		
		INSERT INTO @aeronaves_dias_fuera_de_servicio(aeronave, dias_fuera_de_servicio)
		(SELECT tablaPeriodos.matricula_aeronave, SUM(DATEDIFF(day,tablaPeriodos.fecha_fuera_servicio,tablaPeriodos.fecha_reinicio_servicio)) as cantidad_dias_fuera_de_servicio 
		FROM DBAS.periodosFueraDeServicio tablaPeriodos
		WHERE tablaPeriodos.fecha_reinicio_servicio < @anioDelSemestre AND DATEPART(year,tablaPeriodos.fecha_reinicio_servicio) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaPeriodos.matricula_aeronave) 
		UNION ALL
		(SELECT tablaAeronaves.matricula_aeronave, SUM(DATEDIFF(day,tablaAeronaves.fecha_baja_servicio_definitiva,@GET_DATE)) as cantidad_dias_fuera_de_servicio 
		FROM DBAS.aeronaves tablaAeronaves
		WHERE tablaAeronaves.fecha_baja_servicio_definitiva IS NOT NULL AND @GET_DATE < @anioDelSemestre AND DATEPART(year,@GET_DATE) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaAeronaves.matricula_aeronave)
				
	END
	ELSE
	BEGIN

		INSERT INTO @aeronaves_dias_fuera_de_servicio(aeronave, dias_fuera_de_servicio)
		(SELECT tablaPeriodos.matricula_aeronave, SUM(DATEDIFF(day,tablaPeriodos.fecha_fuera_servicio,tablaPeriodos.fecha_reinicio_servicio)) as cantidad_dias_fuera_de_servicio 
		FROM DBAS.periodosFueraDeServicio tablaPeriodos
		WHERE tablaPeriodos.fecha_reinicio_servicio >= @anioDelSemestre AND DATEPART(year,tablaPeriodos.fecha_reinicio_servicio) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaPeriodos.matricula_aeronave) 
		UNION ALL
		(SELECT tablaAeronaves.matricula_aeronave, SUM(DATEDIFF(day,tablaAeronaves.fecha_baja_servicio_definitiva,@GET_DATE)) as cantidad_dias_fuera_de_servicio 
		FROM DBAS.aeronaves tablaAeronaves
		WHERE tablaAeronaves.fecha_baja_servicio_definitiva IS NOT null AND @GET_DATE >= @anioDelSemestre AND DATEPART(year,@GET_DATE) = DATEPART(year,@anioDelSemestre)
		GROUP BY tablaAeronaves.matricula_aeronave)

	END

	RETURN
END;	
GO

CREATE FUNCTION DBAS.Top5AeronavesConMayorCantidadDeDiasFueraDeServicio(@semestreDelAnio tinyint, @anio integer)
RETURNS @TOP5 TABLE ( aeronave varchar(100), dias_fuera_de_servicio bigint)
AS
BEGIN
	
	-- Devuelvo una tabla con las 5 aeronaves con más dias fuera de servicio
	INSERT INTO @TOP5(aeronave, dias_fuera_de_servicio)
	SELECT TOP 5 tablaDias.aeronave,SUM(tablaDias.dias_fuera_de_servicio) AS tiempo_fuera_servicio
	FROM DBAS.aeronaves_dias_fuera_de_servicio(@semestreDelAnio, @anio) tablaDias
	GROUP BY tablaDias.aeronave
	ORDER BY tiempo_fuera_servicio DESC
				
	RETURN
END;	
GO


CREATE FUNCTION DBAS.Top5ClientesConMasPuntosAcumulados(@semestreDelAnio tinyint, @anio integer)
RETURNS @TOP5 TABLE (id_cliente bigint, puntos_acumulados bigint)
AS
BEGIN
	
	-- Me pasan por parametro el año y lo concateno con una fecha generica que sirve para indicar luego a que semestre pertenece
	DECLARE @anioDelSemestre datetime
	SET @anioDelSemestre = convert(datetime, concat(@anio,'0701 00:00:00.000'))

	DECLARE @comienzoAnio datetime
	SET @comienzoAnio = convert(datetime,concat(@anio,'0101 00:00:00.000'))

	DECLARE @finAnio datetime
	SET @finAnio = convert(datetime,concat(@anio,'1231 00:00:00.000'))

	IF (@semestreDelAnio = 1)
	BEGIN
		-- Devuelvo los 5 clientes con más puntos acumulados en el primer semestre
		INSERT INTO @TOP5(id_cliente,puntos_acumulados)
		SELECT TOP 5 id_cliente, SUM(millas) as puntos
		FROM DBAS.millasAcumuladasEntre(@comienzoAnio,@anioDelSemestre)
		GROUP BY id_cliente
		ORDER BY puntos DESC
	END
	ELSE
	BEGIN
		-- Devuelvo los 5 clientes con más puntos acumulados en el segundo semestre
		INSERT INTO @TOP5(id_cliente,puntos_acumulados)
		SELECT TOP 5 id_cliente, SUM(millas) as puntos
		FROM DBAS.millasAcumuladasEntre(@anioDelSemestre,@finAnio) 
		GROUP BY id_cliente
		ORDER BY puntos DESC
	END
	RETURN
END;
GO

-- Creo la vista para obtener la cantidad de pasajeros por viaje para el TOP 5 aeronaves más vacias
CREATE VIEW DBAS.cantidadPasajerosPorViaje AS
SELECT pasajes.id_viaje,COUNT(codigo_pasaje) as cantidad_pasajeros FROM DBAS.pasajes pasajes
GROUP BY pasajes.id_viaje
GO

CREATE FUNCTION DBAS.Top5AeronavesMasVacias(@semestreDelAnio tinyint, @anio integer)
RETURNS @TOP5 TABLE (id_viaje bigint,matricula_aeronave varchar(100),butacas_vacias bigint,fecha_salida datetime,fecha_llegada datetime,codigo_ruta bigint)
AS
BEGIN
	
	-- Me pasan por parametro el año y lo concateno con una fecha generica que sirve para indicar luego a que semestre pertenece
	DECLARE @anioDelSemestre datetime
	SET @anioDelSemestre = convert(datetime, concat(@anio,'0701 00:00:00.000'))

	DECLARE @comienzoAnio datetime
	SET @comienzoAnio = convert(datetime,concat(@anio,'0101 00:00:00.000'))

	DECLARE @finAnio datetime
	SET @finAnio = convert(datetime,concat(@anio,'1231 00:00:00.000'))

	IF (@semestreDelAnio = 1)
	BEGIN
		-- Devuelvo las 5 aeronaves más vacias con su fecha de salida y llegada y codigo de ruta de primer semestre
		INSERT INTO @TOP5(id_viaje,matricula_aeronave,butacas_vacias,fecha_salida,fecha_llegada,codigo_ruta)
		SELECT TOP 5 tablaPasajeros.id_viaje,matricula_aeronave,(DBAS.cantidadButacas(matricula_aeronave)-cantidad_pasajeros) as butacas_vacias,fecha_salida,fecha_llegada,codigo_ruta
		FROM DBAS.cantidadPasajerosPorViaje tablaPasajeros, DBAS.viajes viajes
		WHERE tablaPasajeros.id_viaje = viajes.id_viaje AND fecha_salida >= @comienzoAnio AND fecha_salida < @anioDelSemestre
		ORDER BY butacas_vacias DESC
	END
	ELSE
	BEGIN
		-- Devuelvo las 5 aeronaves más vacias con su fecha de salida y llegada y codigo de ruta de segundo semestre
		INSERT INTO @TOP5(id_viaje,matricula_aeronave,butacas_vacias,fecha_salida,fecha_llegada,codigo_ruta)
		SELECT TOP 5 tablaPasajeros.id_viaje,matricula_aeronave,(DBAS.cantidadButacas(matricula_aeronave)-cantidad_pasajeros) as butacas_vacias,fecha_salida,fecha_llegada,codigo_ruta
		FROM DBAS.cantidadPasajerosPorViaje tablaPasajeros, DBAS.viajes viajes
		WHERE tablaPasajeros.id_viaje = viajes.id_viaje AND fecha_salida >= @anioDelSemestre AND fecha_salida < @finAnio
		ORDER BY butacas_vacias DESC
	END
	RETURN
END;
GO


/*-- ABM Rol -- */

CREATE FUNCTION DBAS.obtenerFuncionalidadesAsociadas(@nombreRol varchar(100))
RETURNS TABLE
AS
RETURN
(	
	-- Obtengo las funcionalidades de el rol que llega por parametro
	SELECT tablaFuncionalidades.descripcion FROM ((SELECT * FROM DBAS.roles WHERE nombre_rol = @nombreRol) unRol 
		JOIN DBAS.rolesPorFuncionalidad tablaRpF ON (unRol.id_rol = tablaRpF.id_rol)
		JOIN DBAS.funcionalidades tablaFuncionalidades ON (tablaFuncionalidades.id_funcionalidad = tablaRpF.id_funcionalidad))
);
GO


CREATE PROCEDURE DBAS.loginUsuario(@usuario varchar(100), @pass varchar(100))
AS
BEGIN
	DECLARE @U_id bigint
	DECLARE @U_password varchar(100)
	DECLARE @U_habilitado tinyint
	DECLARE @U_rol_id bigint
	DECLARE @cantidad_intentos tinyint
	DECLARE @mensaje_error varchar(100)
	DECLARE @nombre_rol varchar(100)

	-- Obtengo todos los atributos del usuario que me llega por parametro
	SELECT @U_id = tablaUsuarios.id_usuario, @U_password = password, @U_habilitado = habilitado, @cantidad_intentos = intentos_fallidos, @U_rol_id = tablaUporR.id_rol FROM DBAS.usuarios tablaUsuarios, DBAS.usuariosPorRol tablaUporR WHERE tablaUsuarios.username = @usuario AND tablaUporR.id_usuario = tablaUsuarios.id_usuario
	-- Verifico si el usuario existe
	IF (@U_id IS NOT NULL)
	BEGIN
		-- Pregunto si el usuario esta deshabilitado
		IF(@U_habilitado != 1)
		BEGIN
			-- Devuelvo un mensaje de error
			SET @mensaje_error = 'El usuario ingresado se encuentra deshabilitado'
			RAISERROR(@mensaje_error, 12, 1)
		END
		ELSE
		BEGIN
			-- Si el usuario esta habilitado, verifico que la password sea correcta
			IF(@U_password != @pass)
			BEGIN
				-- Compruebo la cantidad de intentos fallidos que se hicieron hasta el momento
				IF(@cantidad_intentos < 2)
				BEGIN
					-- Actualizo la cantidad de intentos fallidos en la base de datos
					UPDATE DBAS.usuarios SET intentos_fallidos = @cantidad_intentos + 1  WHERE username = @usuario
					-- Devuelvo un mensaje de error
					SET @mensaje_error = 'Password invalida'
					RAISERROR(@mensaje_error, 12, 1)
				END
				ELSE
				BEGIN
					-- Actualizo la cantidad de intentos fallidos en la base de datos y deshabilitando al usuario por alcanzar el maximo de intentos
					UPDATE DBAS.usuarios SET intentos_fallidos = @cantidad_intentos + 1, habilitado = 0   WHERE username = @usuario
					-- Devuelvo un mensaje de error
					SET @mensaje_error = 'Password invalida, alcanzo la cantidad de intentos maximos. Se desactivara la cuenta por seguridad'
					RAISERROR(@mensaje_error, 12, 1)
				END
			END
			ELSE
			BEGIN
				-- Si ingreso bien la password receteo los intentos fallidos
				UPDATE DBAS.usuarios SET intentos_fallidos = 0  WHERE username = @usuario

				-- Devuelvo las funcionalidades que le pertenecen al usuario
				SELECT @nombre_rol = nombre_rol FROM DBAS.roles WHERE id_rol = @U_rol_id
				SELECT * FROM DBAS.obtenerFuncionalidadesAsociadas(@nombre_rol)
			END
		END
	END
	ELSE
	BEGIN
		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'El usuario ingresado no existe'
		RAISERROR(@mensaje_error, 12, 1)
	END
END;
GO

-- La vista es creada para que la aplicacion me pueda mandar un INSERT simultaneo como si fuera el de un select, con los parametros de la vista
CREATE VIEW DBAS.modificarRoles AS
SELECT tablaRoles.id_rol, tablaRoles.nombre_rol, tablaRoles.habilitado_rol, tablaRporF.id_funcionalidad FROM DBAS.rolesPorFuncionalidad tablaRporF, DBAS.roles tablaRoles 
WHERE tablaRporF.id_rol = tablaRoles.id_rol
GO

--Trigger creado para el manejo de las inserciones en la vista
CREATE TRIGGER DBAS.modificarRol ON DBAS.modificarRoles
INSTEAD OF INSERT
AS
BEGIN
	DECLARE @habilitado_rol tinyint
	DECLARE @nombre_rol varchar(100)
	DECLARE @id_funcionalidad bigint
	DECLARE @id_rol bigint
	DECLARE @valor_insertado tinyint
	DECLARE @habilitado_estado tinyint

	-- Declaro un cursor sobre los valores insertados
	DECLARE obtenerRolYFuncionalidades CURSOR FOR
	SELECT id_rol, nombre_rol, habilitado_rol, id_funcionalidad FROM inserted

	OPEN obtenerRolYFuncionalidades

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM obtenerRolYFuncionalidades
	INTO @id_rol, @nombre_rol, @habilitado_rol, @id_funcionalidad

	-- Obtengo el atributo de habilitado del rol que se quiere modificar
	SELECT @habilitado_estado = habilitado_rol FROM DBAS.roles WHERE id_rol = @id_rol

	-- Pregunto si el rol esta habilitado y ahora pasa a no estarlo
	IF(@habilitado_estado = 1 AND @habilitado_rol = 0)
	BEGIN
		-- Elimino todas las relaciones que tiene el rol modificado con los usuarios
		DELETE FROM DBAS.usuariosPorRol WHERE id_rol = @id_rol
	END

	-- Actualizo el nombre del rol a modificar
	UPDATE DBAS.roles SET nombre_rol = @nombre_rol, habilitado_rol = @habilitado_rol WHERE id_rol = @id_rol

	-- Elimino todas las funcionlidades asociadas a el rol modificado
	DELETE FROM DBAS.rolesPorFuncionalidad
	WHERE id_rol = @id_rol
 
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		-- Inserto todas las funcionlidades nuevas que tiene el rol modificado
		INSERT INTO DBAS.rolesPorFuncionalidad(id_rol, id_funcionalidad)
		VALUES(@id_rol, @id_funcionalidad)

		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM obtenerRolYFuncionalidades
		INTO @id_rol, @nombre_rol, @habilitado_rol, @id_funcionalidad

	END

	CLOSE obtenerRolYFuncionalidades
	DEALLOCATE obtenerRolYFuncionalidades

END;
GO

-- La vista es creada para que la aplicacion me pueda mandar un INSERT simultaneo como si fuera el de un select, con los parametros de la vista
CREATE VIEW DBAS.rolesConFuncionalidades AS
SELECT tablaRoles.nombre_rol, tablaRporF.id_funcionalidad FROM DBAS.rolesPorFuncionalidad tablaRporF, DBAS.roles tablaRoles 
WHERE tablaRporF.id_rol = tablaRoles.id_rol
GO

--Trigger creado para el manejo de las inserciones en la vista
CREATE TRIGGER DBAS.crearRolConFuncionalidades ON DBAS.rolesConFuncionalidades
INSTEAD OF INSERT
AS
BEGIN

	DECLARE @nombre_rol varchar(100)
	DECLARE @id_funcionalidad bigint
	DECLARE @id_rol bigint
	DECLARE @valor_insertado tinyint

	SET @valor_insertado = 0
	
	-- Creo un cursor para manejar cada valor insertado
	DECLARE obtenerRolYFuncionalidades CURSOR FOR
	SELECT nombre_rol, id_funcionalidad FROM inserted

	OPEN obtenerRolYFuncionalidades

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM obtenerRolYFuncionalidades
	INTO @nombre_rol, @id_funcionalidad

	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Sirve para no volver a insertar de nuevo el rol que llega del trigger, ya que llega repetido por cada fila insertada
		IF(@valor_insertado = 0)
		BEGIN
			INSERT INTO DBAS.roles(nombre_rol)
			VALUES(@nombre_rol)

			-- Obtengo la id del rol insertado
			SET @id_rol = SCOPE_IDENTITY()
			SET @valor_insertado =1
		END

		-- Inserto las relaciones del rol nuevo con sus funcionalidades elegidas
		INSERT INTO rolesPorFuncionalidad(id_rol, id_funcionalidad)
		VALUES(@id_rol, @id_funcionalidad)

		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM obtenerRolYFuncionalidades
		INTO @nombre_rol, @id_funcionalidad

	END

	CLOSE obtenerRolYFuncionalidades
	DEALLOCATE obtenerRolYFuncionalidades

END;
GO

CREATE PROCEDURE DBAS.altaPersona(
	@dni_persona bigint ,
	@nombre_persona varchar(100),
	@apellido_persona varchar(100),
	@direccion_persona varchar(100),
	@telefono_persona varchar(50),
	@mail_persona varchar(100),
	@fecha_nacimiento datetime,
	@ID_persona bigint OUT)
AS
BEGIN
	
	-- Creo a la persona con los parametros ingresados
	INSERT INTO DBAS.personas(dni_persona,nombre_persona,apellido_persona,direccion_persona,telefono_persona,mail_persona,fecha_nacimiento)
	VALUES( @dni_persona,@nombre_persona,@apellido_persona,@direccion_persona,@telefono_persona,@mail_persona,@fecha_nacimiento)

	-- Inserto el id de la persona creada y lo devuelvo para su manejo
	SET @ID_persona = SCOPE_IDENTITY()

END;
GO

CREATE PROCEDURE DBAS.altaCliente(@dni_persona bigint ,
	@nombre_persona varchar(100),
	@apellido_persona varchar(100),
	@direccion_persona varchar(100),
	@telefono_persona varchar(50),
	@mail_persona varchar(100),
	@fecha_nacimiento datetime)
AS
BEGIN
	DECLARE @ID_persona bigint

	-- Doy de alta a la persona y obtengo su id
	EXECUTE DBAS.altaPersona @dni_persona,@nombre_persona,@apellido_persona,@direccion_persona,	@telefono_persona,@mail_persona,@fecha_nacimiento, @ID_persona OUT

	-- Con la id de la persona creo un cliente
	INSERT INTO DBAS.clientes(id_persona)
	VALUES (@ID_persona)

END;
GO

/* -- ABM Aeronave -- */

CREATE PROCEDURE DBAS.altaAeronave(@ID_fabricante bigint, @ID_servicio bigint, @matricula_aeronave varchar(100), @modelo varchar(100), @KG_disponible float(24), @butacas_pasillo bigint, @butacas_ventana bigint, @piso tinyint)
AS
BEGIN
	DECLARE @mensaje_error varchar(100)
	DECLARE @nro_butaca bigint
	DECLARE @butacas_pasillo_AUX bigint
	DECLARE @butacas_ventana_AUX bigint
	
	SET @nro_butaca = 0
	
	-- Pregunto si la matricula nueva ingresada ya existe
	IF EXISTS(SELECT * FROM DBAS.aeronaves WHERE matricula_aeronave = @matricula_aeronave)
	BEGIN
		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'La matricula ingresada ya existe'
		RAISERROR(@mensaje_error, 12, 1)
	END
	ELSE
	BEGIN
		-- Inserto la aeronave nueva con todas sus caracteristicas
		INSERT INTO DBAS.aeronaves(matricula_aeronave, modelo_aeronave, kg_disponible_encomienda, id_fabricante, id_servicio)
		VALUES(@matricula_aeronave, @modelo, @KG_disponible, @ID_fabricante, @ID_servicio)

		-- Inserto la cantidad de butacas pasillo y ventanillas por piso de la nueva aeronave
		WHILE(@piso != 0)
		BEGIN
			-- Auxiliares para la cantidad de butacas por piso
			SET @butacas_pasillo_AUX = @butacas_pasillo
			SET @butacas_ventana_AUX = @butacas_ventana

			WHILE(@butacas_pasillo_AUX != 0)
			BEGIN
				SET @nro_butaca += 1

				INSERT INTO DBAS.butacas(matricula_aeronave, numero_butaca, piso_butaca, tipo_butaca)
				VALUES(@matricula_aeronave, @nro_butaca, @piso, 'Pasillo')

				SET @butacas_pasillo_AUX -= 1
			END

			WHILE(@butacas_ventana_AUX != 0)
			BEGIN
				SET @nro_butaca += 1

				INSERT INTO DBAS.butacas(matricula_aeronave, numero_butaca, piso_butaca, tipo_butaca)
				VALUES(@matricula_aeronave, @nro_butaca, @piso, 'Ventanilla')

				SET @butacas_ventana_AUX -= 1
			END
		
			SET @piso -= 1
		
		END

	END
END;
GO



CREATE PROCEDURE DBAS.cancelacionPasaje(@motivo_cancelacion varchar(100), @ID_cancelacion bigint OUT)
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	-- Inserto un nueva cancelacion con su motivo y la fecha actual
	INSERT INTO DBAS.cancelaciones(fecha_devolucion, motivo_cancelacion)
	VALUES(@GET_DATE, @motivo_cancelacion)

	-- Seteo la variable con la id de la cancelacion y la devuelvo para su manejo
	SET @ID_cancelacion = SCOPE_IDENTITY()

END;
GO

CREATE PROCEDURE DBAS.actualizarBajaAeronave(@fecha datetime, @matricula_aeronave varchar(100), @tipo_cancelacion tinyint)
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	-- Pregunto si el tipo de baja es temporal o definitiva
	IF(@tipo_cancelacion = 1)
	BEGIN
		-- Doy de baja temporal a la aeronave y le indico una fecha de reinsercion
		INSERT INTO DBAS.periodosFueraDeServicio(matricula_aeronave, fecha_reinicio_servicio, fecha_fuera_servicio)
		VALUES(@matricula_aeronave, @fecha, @GET_DATE)
	END
	ELSE
	BEGIN
		-- Doy de baja definitiva a la aeronave
		UPDATE DBAS.aeronaves SET fecha_baja_servicio_definitiva = @fecha WHERE matricula_aeronave = @matricula_aeronave
	END
END;
GO

CREATE FUNCTION DBAS.estaEnViajeAeronave(@matricula_aeronave varchar(100)) 
RETURNS tinyint
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	-- Pregunto si la aeronave que llega por parametro esta en viaje actualmente y devuelve 0 si lo esta y 1 si esta disponible
	IF EXISTS(SELECT * FROM DBAS.viajes WHERE matricula_aeronave = @matricula_aeronave AND fecha_salida < @GET_DATE AND fecha_llegada IS NULL)
	BEGIN
		RETURN 0
	END
	ELSE
	BEGIN
		RETURN 1
	END
END;
GO

CREATE FUNCTION DBAS.ciudadAeronave(@matricula_aeronave varchar(100)) 
RETURNS bigint
AS
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Devuelvo la id de la ciudad actual de la aeronave ingresada por parametro 
	RETURN (SELECT TOP 1 tablaCiudades.id_ciudad FROM DBAS.viajes tablaViajes, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades 
	WHERE tablaViajes.matricula_aeronave = @matricula_aeronave AND tablaViajes.fecha_llegada <= @GET_DATE 
	AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta AND tablaRutas.ciudad_destino_id = tablaCiudades.id_ciudad
	ORDER BY tablaViajes.fecha_llegada DESC)
	
END;
GO

CREATE FUNCTION DBAS.ultimaLlegadaConfirmadaAeronave(@matricula_aeronave varchar(100)) 
RETURNS bigint
AS
BEGIN
	DECLARE @id_viaje bigint

	-- Pregunto si no existe la aeronave actual en pleno vuelo, retornando null si esta en vuelo y sino devuelvo el ultimo viaje que realizo
	IF NOT EXISTS(SELECT TOP 1 id_viaje FROM DBAS.viajes WHERE matricula_aeronave = @matricula_aeronave AND fecha_llegada IS NULL)
	BEGIN
		SELECT TOP 1 @id_viaje = id_viaje FROM DBAS.viajes WHERE matricula_aeronave = @matricula_aeronave ORDER BY fecha_salida DESC
	END
	ELSE
	BEGIN
		SET @id_viaje = NULL
	END
	
	RETURN @id_viaje
END;
GO

CREATE FUNCTION DBAS.aeronavesEnServicio()
RETURNS @aeronavesEnServicio TABLE (matricula_aeronave varchar(100))
AS
BEGIN
	DECLARE @matriculaAeronave varchar(100)
	DECLARE @fecha_reincercion datetime
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Creo un cursor para las aeronaves que no esten dados de baja
	DECLARE aeronaves CURSOR FOR
	SELECT matricula_aeronave FROM DBAS.aeronaves WHERE fecha_baja_servicio_definitiva IS NULL

	OPEN aeronaves

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM aeronaves
	INTO @matriculaAeronave

	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Pregunto si alguna vez la aeronave estaba fuera de servicio
		IF EXISTS(SELECT * FROM DBAS.periodosFueraDeServicio WHERE matricula_aeronave = @matriculaAeronave)
		BEGIN
			--Obtengo la fecha más reciente de reincercion
			SELECT TOP 1 @fecha_reincercion = fecha_reinicio_servicio FROM DBAS.periodosFueraDeServicio WHERE matricula_aeronave = @matriculaAeronave
			ORDER BY fecha_reinicio_servicio DESC

			--Pregunto si la fecha de reincercion es menor a la de hoy
			IF(@fecha_reincercion <= @GET_DATE)
			BEGIN
				--Retorno la aeronave
				INSERT INTO @aeronavesEnServicio(matricula_aeronave)
				VALUES(@matriculaAeronave)
			END
		END
		ELSE
		BEGIN
			--Retorno la aeronave
			INSERT INTO @aeronavesEnServicio(matricula_aeronave)
			VALUES(@matriculaAeronave)
		END

		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM aeronaves
		INTO @matriculaAeronave
	END

	CLOSE aeronaves
	DEALLOCATE aeronaves

	RETURN
END;
GO


CREATE FUNCTION DBAS.aeronavesDisponiblesParaReemplazo()
RETURNS @aeronavesDisponiblesParaReemplazo TABLE (matricula_aeronave varchar(100),id_viaje bigint)
AS
BEGIN

	DECLARE @matriculaAer varchar (100)
	DECLARE @id_Viaje bigint

	-- Creo un cursor de la aeronaves que estan en servicio
	DECLARE aeronaves CURSOR FOR
	SELECT matricula_aeronave FROM DBAS.aeronavesEnServicio()

	OPEN aeronaves

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM aeronaves
	INTO @matriculaAer

	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Pregunto si la aeronave existe en algun viaje
		IF EXISTS(SELECT * FROM DBAS.viajes WHERE matricula_aeronave = @matriculaAer)
		BEGIN
			-- Obtengo el id viaje del ultimo viaje, si es que no esta en vuelo, llamando a la funcion
			SET @id_Viaje = DBAS.ultimaLlegadaConfirmadaAeronave(@matriculaAer)
			IF(@id_Viaje IS NOT NULL)
			BEGIN
				-- Devuelvo una tabla que contiene la matricula y la id de su ultimo viaje
				INSERT INTO @aeronavesDisponiblesParaReemplazo VALUES (@matriculaAer,@id_Viaje)
			END
		END
		ELSE
		BEGIN
			-- Devuelvo una tabla que contiene la matricula y la id de su ultimo viaje en null porque no tiene viajes
			INSERT INTO @aeronavesDisponiblesParaReemplazo VALUES (@matriculaAer,NULL)
		END
		
		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM aeronaves
		INTO @matriculaAer
	END

	CLOSE aeronaves
	DEALLOCATE aeronaves

	RETURN

END;
GO

CREATE FUNCTION DBAS.aeronavesDisponiblesSinVuelo(@matricula_aeronave varchar(100))
RETURNS @avionesSinVuelo TABLE (matricula_aeronave varchar(100))
AS 
BEGIN
	DECLARE @ciudad_actual_id bigint
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time 
	
	-- Obtengo la ciudad actual de la aeronave a reemplazar
	SET @ciudad_actual_id = DBAS.ciudadAeronave(@matricula_aeronave)
	
	-- Devuelvo todas la aeronaves disponibles para reemplazar a la actual que no tengan ningun vuelo programado
	INSERT INTO  @avionesSinVuelo
	SELECT DISTINCT tablaViajes.matricula_aeronave FROM DBAS.viajes tablaViajes, DBAS.aeronavesDisponiblesParaReemplazo() tablaAeronavesTemp, DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades
	WHERE (tablaAeronavesTemp.id_viaje = tablaViajes.id_viaje OR tablaAeronavesTemp.id_viaje IS NULL) AND tablaViajes.fecha_llegada <= @GET_DATE 
	AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta AND tablaRutas.ciudad_destino_id = @ciudad_actual_id

	RETURN	
		
END;
GO

CREATE FUNCTION DBAS.cantidadButacas(@matricula_aeronave varchar(100))
RETURNS INTEGER
AS
BEGIN
	-- Devuelvo la cantidad de butacas que tiene una aeronave en total
	RETURN (SELECT COUNT(id_butaca) FROM DBAS.butacas WHERE matricula_aeronave = @matricula_aeronave AND piso_butaca != 0)

END;
GO

-- Trigger para reemplazar las butacas de un viaje de los pasajes cuando se reemplaza la aeronave
CREATE TRIGGER DBAS.reemplazarButacasEnViajes ON DBAS.viajes
AFTER UPDATE
AS
BEGIN
		DECLARE @id_viaje bigint
		DECLARE @matricula_aeronave_nueva varchar(100)
		DECLARE @id_pasaje bigint
		DECLARE @id_butaca bigint
	
		-- Obtengo todos los viajes que fueron reemplazados por una aeronave
		DECLARE viajesCursor CURSOR FOR
		SELECT id_viaje, matricula_aeronave FROM inserted

		OPEN viajesCursor

		-- Inserto lo que obtiene el cursor en las variables
		FETCH NEXT FROM viajesCursor
		INTO @id_viaje, @matricula_aeronave_nueva

		WHILE @@FETCH_STATUS = 0
		BEGIN
			UPDATE DBAS.viajes SET matricula_aeronave = @matricula_aeronave_nueva WHERE id_viaje = @id_viaje

			-- Obtengo cada pasaje que tenga este viaje
			DECLARE pasajesCursor CURSOR FOR
			SELECT @id_pasaje FROM  DBAS.pasajes
			WHERE  DBAS.pasajes.id_viaje = @id_viaje

			-- Obtengo las butacas de la aeronave nueva
			DECLARE butacaCursor CURSOR FOR
			SELECT @id_butaca FROM  DBAS.butacas
			WHERE  matricula_aeronave = @matricula_aeronave_nueva
			
			OPEN pasajesCursor
			OPEN butacaCursor

			-- Inserto lo que obtiene el cursor en las variables
			FETCH NEXT FROM pasajesCursor
			INTO @id_pasaje

			-- Inserto lo que obtiene el cursor en las variables
			FETCH NEXT FROM butacaCursor
			INTO @id_butaca

			WHILE @@FETCH_STATUS = 0
			BEGIN
				
				-- Reemplazo todas las butacas de cada pasaje del viaje
				UPDATE DBAS.pasajes SET id_butaca = @id_butaca WHERE id_viaje = @id_viaje

				-- Inserto lo que obtiene el cursor en las variables
				FETCH NEXT FROM butacaCursor
				INTO @id_butaca

				-- Inserto lo que obtiene el cursor en las variables
				FETCH NEXT FROM pasajesCursor
				INTO @id_pasaje
			END

			CLOSE pasajesCursor
			DEALLOCATE pasajesCursor

			CLOSE butacaCursor
			DEALLOCATE butacaCursor
			
			-- Inserto lo que obtiene el cursor en las variables
			FETCH NEXT FROM viajesCursor
			INTO @id_viaje, @matricula_aeronave_nueva
		
		END

		CLOSE viajesCursor
		DEALLOCATE viajesCursor
END;
GO


CREATE PROCEDURE DBAS.cancelacionPasajesBajaAeronave(@fecha datetime, @matricula_aeronave varchar(100), @tipo_cancelacion tinyint)
AS
BEGIN
	DECLARE @ID_cancelacion bigint
	DECLARE @motivo_cancelacion varchar(100)
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Seteo el motivo de la cancelacion
	SET @motivo_cancelacion = 'La aeronave fue dada de baja'

	-- Inserto la cancelacion con su motivo y obtengo su id para la asignacion de los pasajes y encomiendas que seran cancelados
	EXECUTE DBAS.cancelacionPasaje @motivo_cancelacion, @ID_cancelacion OUT
	
	-- Pregunto que tipo de cancelacion es, si es uno solo cancelo los pasajes hasta la fecha de reinsercion de la aeronave, sino todos los pasajes posteriores	
	IF(@tipo_cancelacion = 1)
	BEGIN
		
		-- Actualizo los pasajes que tienen a la aeronave que se da de baja con el id cancelacion obtenido
		UPDATE tablaPasajes SET tablaPasajes.id_cancelacion = @ID_cancelacion 
		FROM  DBAS.viajes tablaViajes, DBAS.pasajes tablaPasajes
		WHERE tablaViajes.fecha_salida > @GET_DATE AND tablaViajes.fecha_salida < @fecha 
		AND tablaPasajes.id_viaje = tablaViajes.id_viaje
		AND tablaViajes.matricula_aeronave = @matricula_aeronave
	
		-- Actualizo las encomiendas que tienen a la aeronave que se da de baja con el id cancelacion obtenido
		UPDATE tablaEncomiendas SET tablaEncomiendas.id_cancelacion = @ID_cancelacion 
		FROM  DBAS.viajes tablaViajes, DBAS.encomiendas tablaEncomiendas
		WHERE  tablaViajes.fecha_salida > @GET_DATE AND tablaViajes.fecha_salida < @fecha 
		AND tablaEncomiendas.id_viaje = tablaViajes.id_viaje
		AND tablaViajes.matricula_aeronave = @matricula_aeronave

		--Deshabilito el viaje para que no se pueda vender pasajes ni encomiendas
		UPDATE DBAS.viajes SET habilitado_viaje = 0 WHERE matricula_aeronave = @matricula_aeronave AND fecha_salida > @GET_DATE AND fecha_salida < @fecha 
	
	END
	ELSE
	BEGIN
		
		-- Actualizo los pasajes que tienen a la aeronave que se da de baja con el di cancelacion obtenido
		UPDATE tablaPasajes SET tablaPasajes.id_cancelacion = @ID_cancelacion 
		FROM  DBAS.viajes tablaViajes, DBAS.pasajes tablaPasajes
		WHERE  tablaViajes.fecha_salida > @GET_DATE
		AND tablaPasajes.id_viaje = tablaViajes.id_viaje
		AND tablaViajes.matricula_aeronave = @matricula_aeronave
		
		UPDATE tablaEncomiendas SET tablaEncomiendas.id_cancelacion = @ID_cancelacion 
		FROM  DBAS.viajes tablaViajes, DBAS.encomiendas tablaEncomiendas
		WHERE tablaViajes.fecha_salida > @GET_DATE
		AND tablaEncomiendas.id_viaje = tablaViajes.id_viaje
		AND tablaViajes.matricula_aeronave = @matricula_aeronave

		--Deshabilito el viaje para que no se pueda vender pasajes ni encomiendas
		UPDATE DBAS.viajes SET habilitado_viaje = 0 WHERE matricula_aeronave = @matricula_aeronave AND fecha_salida > @GET_DATE
		
	END

	-- Doy de baja la aeronave una vez actualizados los datos
	EXECUTE DBAS.actualizarBajaAeronave @fecha, @matricula_aeronave, @tipo_cancelacion

END;
GO

CREATE PROCEDURE DBAS.reemplazarAeronave(@matricula_aeronave_original varchar(100),@matricula_aeronave_nueva varchar(100),@baja_temporal tinyint, @fecha datetime)
AS 
BEGIN
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	-- Pregunto que tipo de reemplazo es, si es uno solo cancelo los pasajes hasta la fecha de reinsercion de la aeronave, sino todos los pasajes posteriores	
	IF (@baja_temporal = 1)
	BEGIN
		
		-- Actualizo los viajes que tengan la matricula aeronave viejo por la nueva
		UPDATE DBAS.viajes SET matricula_aeronave = @matricula_aeronave_nueva 
		WHERE fecha_salida > @GET_DATE AND fecha_salida < @fecha AND matricula_aeronave = @matricula_aeronave_original

	END
	ELSE
	BEGIN
		
		-- Actualizo los viajes que tengan la matricula aeronave viejo por la nueva
		UPDATE DBAS.viajes SET matricula_aeronave = @matricula_aeronave_nueva 
		WHERE fecha_salida > @GET_DATE AND matricula_aeronave = @matricula_aeronave_original

	END
END;
GO


CREATE FUNCTION DBAS.aeronavesDeReemplazo(@matricula_aeronave varchar(100))
RETURNS @avionesSinVuelo TABLE (matricula_aeronave varchar(100), cantidad_butacas bigint)
AS 
BEGIN
	
	-- Devuelvo todas las aeronaves que pueden reemplazar a la aeronave psada por parametro
	INSERT INTO @avionesSinVuelo
	SELECT tablaAeronaves1.matricula_aeronave, DBAS.cantidadButacas(tablaAeronaves1.matricula_aeronave) FROM  DBAS.aeronavesDisponiblesSinVuelo(@matricula_aeronave) avionesDisponibles, DBAS.aeronaves tablaAeronaves1, DBAS.aeronaves tablaAeronaves2
	WHERE DBAS.cantidadButacas(avionesDisponibles.matricula_aeronave) >= DBAS.cantidadButacas(@matricula_aeronave) AND tablaAeronaves1.matricula_aeronave = avionesDisponibles.matricula_aeronave AND tablaAeronaves2.matricula_aeronave = @matricula_aeronave
	AND tablaAeronaves1.id_servicio = tablaAeronaves2.id_servicio AND tablaAeronaves1.id_fabricante = tablaAeronaves2.id_fabricante
	
	RETURN
END;
GO

CREATE PROCEDURE DBAS.bajaAeronave(@fecha datetime, @matricula_aeronave varchar(100), @tipo_cancelacion tinyint)
AS
BEGIN
	DECLARE @mensaje_error varchar(100)
	DECLARE @ciudad_actual_id bigint
	
	-- Pregunto si la aeronave esta en algun viaje antes de reemplazar
	IF EXISTS(SELECT * FROM DBAS.viajes WHERE matricula_aeronave = @matricula_aeronave)
	BEGIN
		
		--Pregunto si la aeronave esta en vuelo
		IF (DBAS.estaEnViajeAeronave(@matricula_aeronave) = 0)
		BEGIN
			-- Devuelvo un mensaje de error
			SET @mensaje_error = 'No puede dar de baja la aeronave, esta en vuelo'
			RAISERROR(@mensaje_error, 12, 1)
		
		END
		ELSE
		BEGIN
			-- Devuelvo un mensaje de error
			SET @mensaje_error = 'La aeronave esta en uso'
			RAISERROR(@mensaje_error, 12, 1)
		END
	END
	ELSE
	BEGIN
		-- Se da de baja la aeronave llamando al procedure
		EXECUTE DBAS.actualizarBajaAeronave @fecha, @matricula_aeronave, @tipo_cancelacion
	END
END;
GO


CREATE PROCEDURE DBAS.modificarAeronave(@matricula_aeronave varchar(100), @ID_fabricante bigint, @ID_servicio bigint, @matricula_aeronave_nueva varchar(100), @modelo varchar(100), @KG_disponible float(24), @butacas_pasillo bigint, @butacas_ventana bigint, @piso tinyint)
AS
BEGIN
	DECLARE @mensaje_error varchar(100)

	-- Pregunto si la aeronave esta en algun viaje
	IF EXISTS(SELECT * FROM DBAS.viajes WHERE matricula_aeronave = @matricula_aeronave)
	BEGIN
		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'La aeronave fue usada, no puede modificarla'
		RAISERROR(@mensaje_error, 12, 1)
	END
	ELSE
	BEGIN
		-- Elimino todas las referencias de la aeronave a modificar
		DELETE DBAS.butacas WHERE matricula_aeronave = @matricula_aeronave
		DELETE DBAS.aeronaves WHERE matricula_aeronave = @matricula_aeronave

		-- Se da de alta una aeronave para las nuevas modificaciones de la vieja
		EXECUTE DBAS.altaAeronave @ID_fabricante, @ID_servicio, @matricula_aeronave_nueva, @modelo, @KG_disponible, @butacas_pasillo, @butacas_ventana, @piso
	END
END;
GO


/* -- Rutas -- */

-- La vista es creada para que la aplicacion me pueda mandar un INSERT simultaneo como si fuera el de un select, con los parametros de la vista
CREATE VIEW DBAS.caracteristicasRutas AS
SELECT tablaRutas.codigo_ruta, tablaRutas.precio_base_por_KG, tablaRutas.precio_base_por_pasaje, tablaCiudad_origen.nombre_ciudad as ciudad_Origen, tablaCiudad_destino.nombre_ciudad as ciudad_Destino, tablaServicios.tipo_servicio, tablaServicios.porcentaje_arancel
FROM DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudad_origen, DBAS.ciudades tablaCiudad_destino, DBAS.servicios tablaServicios, DBAS.serviciosPorRutas tablaSporR
WHERE tablaRutas.habilitada_ruta = 1 AND tablaRutas.ciudad_origen_id = tablaCiudad_origen.id_ciudad AND tablaRutas.ciudad_destino_id = tablaCiudad_destino.id_ciudad
AND tablaSporR.codigo_ruta = tablaRutas.codigo_ruta AND tablaServicios.id_servicio = tablaSporR.id_servicio
GO

-- Creo un trigger para manejar las nuevas rutas ingresadas en la vista
CREATE TRIGGER DBAS.altaRutas ON DBAS.caracteristicasRutas
INSTEAD OF INSERT
AS
BEGIN
	DECLARE @codigo_ruta bigint
	DECLARE @ciudad_Origen varchar(100)
	DECLARE @ciudad_Destino varchar(100)
	DECLARE @ID_ciudad_Origen bigint
	DECLARE @ID_ciudad_Destino bigint
	DECLARE @tipo_servicio varchar(100)
	DECLARE @precio_KG float(24)
	DECLARE @precio_pasaje float(24)
	DECLARE @id_servicio bigint

	-- Creo un cursor para las el manejo de las nuevas rutas insertadas
	DECLARE rutasCursor CURSOR FOR
	SELECT CAST(precio_base_por_KG AS float(24)), CAST(precio_base_por_pasaje AS float(24)), ciudad_Origen, ciudad_Destino, tipo_servicio FROM inserted

	OPEN rutasCursor

	FETCH NEXT FROM rutasCursor
	INTO @precio_KG, @precio_pasaje, @ciudad_Origen, @ciudad_Destino, @tipo_servicio

	-- Obtengo las id de las ciudades con los nombres de la nueva ruta
	SELECT @ID_ciudad_Origen = id_ciudad FROM DBAS.ciudades WHERE nombre_ciudad = @ciudad_Origen
	SELECT @ID_ciudad_Destino = id_ciudad FROM DBAS.ciudades WHERE nombre_ciudad = @ciudad_Destino

	-- Inserto la nueva ruta con sus caracteristicas
	INSERT INTO DBAS.rutas(precio_base_por_KG, precio_base_por_pasaje, ciudad_origen_id, ciudad_destino_id)
	VALUES (@precio_KG, @precio_pasaje, @ID_ciudad_Origen, @ID_ciudad_Destino)

	-- Obtengo el codigo de la ruta para su utilizacion
	SET @codigo_ruta = SCOPE_IDENTITY()
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--Obtengo el id del servicio que fueron seleccionados de la ruta
		SELECT @id_servicio = id_servicio FROM DBAS.servicios WHERE tipo_servicio = @tipo_servicio

		-- Establezco la relacion entre la nueva ruta y los servicios seleccionados
		INSERT INTO DBAS.serviciosPorRutas(codigo_ruta, id_servicio)
		VALUES (@codigo_ruta, @id_servicio)

		FETCH NEXT FROM rutasCursor
		INTO @precio_KG, @precio_pasaje, @ciudad_Origen, @ciudad_Destino, @tipo_servicio
	END

	CLOSE rutasCursor
	DEALLOCATE rutasCursor

END;
GO


CREATE TRIGGER DBAS.modificacionRutas ON DBAS.caracteristicasRutas
INSTEAD OF UPDATE
AS
BEGIN
	DECLARE @codigo_ruta bigint
	DECLARE @ciudad_Origen varchar(100)
	DECLARE @ciudad_Destino varchar(100)
	DECLARE @ID_ciudad_Origen bigint
	DECLARE @ID_ciudad_Destino bigint
	DECLARE @tipo_servicio varchar(100)
	DECLARE @precio_KG float(24)
	DECLARE @precio_pasaje float(24)
	DECLARE @id_servicio bigint

	-- Creo un cursor para las el manejo de la ruta a modificar
	DECLARE rutasCursor CURSOR FOR
	SELECT codigo_ruta, CAST(precio_base_por_KG AS float(24)), CAST(precio_base_por_pasaje AS float(24)), ciudad_Origen, ciudad_Destino, tipo_servicio FROM inserted

	OPEN rutasCursor

	FETCH NEXT FROM rutasCursor
	INTO @codigo_ruta, @precio_KG, @precio_pasaje, @ciudad_Origen, @ciudad_Destino, @tipo_servicio

	-- Obtengo las id de las nuevas ciudades que va a tener la ruta
	SELECT @ID_ciudad_Origen = id_ciudad FROM DBAS.ciudades WHERE nombre_ciudad = @ciudad_Origen
	SELECT @ID_ciudad_Destino = id_ciudad FROM DBAS.ciudades WHERE nombre_ciudad = @ciudad_Destino

	-- Actualizo los valores de la ruta a modificar
	UPDATE DBAS.rutas SET precio_base_por_KG = @precio_KG, precio_base_por_pasaje = @precio_pasaje, ciudad_origen_id = @ID_ciudad_Origen, ciudad_destino_id = @ID_ciudad_Destino WHERE codigo_ruta = @codigo_ruta

	-- Elimino las relaciones de la ruta con los viejos servicios
	DELETE FROM DBAS.serviciosPorRutas
	WHERE codigo_ruta = @codigo_ruta
	
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--Obtengo el id del servicio que fueron seleccionados de la ruta
		SELECT @id_servicio = id_servicio FROM DBAS.servicios WHERE tipo_servicio = @tipo_servicio

		-- Establezco la relacion entre la nueva ruta y los servicios seleccionados
		INSERT INTO DBAS.serviciosPorRutas(codigo_ruta, id_servicio)
		VALUES (@codigo_ruta, @id_servicio)

		FETCH NEXT FROM rutasCursor
		INTO @codigo_ruta, @precio_KG, @precio_pasaje, @ciudad_Origen, @ciudad_Destino, @tipo_servicio

	END

	CLOSE rutasCursor
	DEALLOCATE rutasCursor

END;
GO

CREATE PROCEDURE DBAS.bajaRuta(@codigo_ruta bigint)
AS
BEGIN
	DECLARE @mensaje_error varchar(100)
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time
	
	-- Pregunto si existe un viaje que utiliza a la ruta para saber si se puede modificar
	IF EXISTS(SELECT * FROM DBAS.viajes WHERE codigo_ruta = @codigo_ruta AND fecha_salida > @GET_DATE)
	BEGIN
		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'Hay viajes futuros por esta ruta'
		RAISERROR(@mensaje_error, 12, 1)
	END
	ELSE
	BEGIN
		-- Deshabilito la ruta
		UPDATE DBAS.rutas SET habilitada_ruta = 0 WHERE codigo_ruta = @codigo_ruta
	END
END;
GO

CREATE PROCEDURE DBAS.bajaRutaYCancelarPasajes(@codigo_ruta bigint)
AS
BEGIN
	DECLARE @motivo_cancelacion varchar(100)
	DECLARE @ID_cancelacion bigint
	DECLARE @GET_DATE datetime

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Seteo el motivo de cancelacion
	SET @motivo_cancelacion = 'Baja ruta de vuelo' 

	-- Inserto la cancelacion y obtengo su id
	EXECUTE DBAS.cancelacionPasaje @motivo_cancelacion, @ID_cancelacion OUT
	
	-- Actualizo todos los pasajes que contengan la ruta que se da de baja e inserto el id de cancelacion	
	UPDATE tablaPasajes SET tablaPasajes.id_cancelacion = @ID_cancelacion 
	FROM  DBAS.viajes tablaViajes, DBAS.pasajes tablaPasajes
	WHERE tablaViajes.fecha_salida > @GET_DATE
	AND tablaPasajes.id_viaje = tablaViajes.id_viaje
	AND tablaViajes.codigo_ruta= @codigo_ruta
	
	-- Actualizo todos los pasajes que contengan la ruta que se da de baja e inserto el id de cancelacion
	UPDATE tablaEncomiendas SET tablaEncomiendas.id_cancelacion = @ID_cancelacion 
	FROM  DBAS.viajes tablaViajes, DBAS.encomiendas tablaEncomiendas
	WHERE  tablaViajes.fecha_salida > @GET_DATE
	AND tablaEncomiendas.id_viaje = tablaViajes.id_viaje
	AND tablaViajes.codigo_ruta= @codigo_ruta

	-- Deshabilito la ruta
	UPDATE DBAS.rutas SET habilitada_ruta = 0 WHERE codigo_ruta = @codigo_ruta

END;
GO

/* -- ABM Viajes -- */


CREATE FUNCTION DBAS.ultimaCiudadAeronave(@matricula_aeronave varchar(100)) 
RETURNS bigint
AS
BEGIN
	
	-- Devuelvo la ciudad en donde esta la aeronave actualmente
	RETURN (SELECT TOP 1 tablaViajes.id_viaje FROM DBAS.viajes tablaViajes
	WHERE tablaViajes.matricula_aeronave = @matricula_aeronave AND tablaViajes.habilitado_viaje = 1
	ORDER BY tablaViajes.fecha_salida DESC)
	
END;
GO

CREATE PROCEDURE DBAS.altaViaje(@matricula_aeronave varchar(100), @fecha_salida datetime, @fecha_llegada_estimada datetime, @codigo_ruta bigint)
AS
BEGIN
	DECLARE @ID_viaje bigint
	DECLARE @ID_ultima_ciudad bigint
	DECLARE @ID_ciudad_origen_nueva bigint
	DECLARE @fecha_disponible datetime

	DECLARE @mensaje_error varchar(100)
	
	-- Obtengo el ultimo viaje de la aeronave
	SET @ID_viaje = DBAS.ultimaCiudadAeronave(@matricula_aeronave)

	--Obtengo las caracteristicas de la ruta en el que tien el id viaje obtenido
	SELECT @ID_ultima_ciudad = tablaRutas.ciudad_destino_id, @fecha_disponible = tablaViajes.fecha_llegada_estimada FROM DBAS.viajes tablaViajes, DBAS.rutas tablaRutas
	WHERE tablaViajes.id_viaje = @ID_viaje AND tablaViajes.codigo_ruta = tablaRutas.codigo_ruta
	
	-- Compruebo que la fecha de salida sea mayor a la fecha de la llegada de la aeronave de su ultimo viaje
	IF(@fecha_disponible >= @fecha_salida)
	BEGIN

		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'La fecha de salida ingresada no esta disponible'
		RAISERROR(@mensaje_error, 12, 1)

	END
	ELSE
	BEGIN
		--Obtengo la id de la ciudad origen de la ruta seleccionada para el nuevo viaje
		SELECT @ID_ciudad_origen_nueva = ciudad_origen_id FROM DBAS.rutas WHERE codigo_ruta = @codigo_ruta

		-- Compruebp que la ultima ciudad en el que esta la aeronave coincida con la ciudad origen de la ruta ingresada
		IF(@ID_ultima_ciudad != @ID_ciudad_origen_nueva)
		BEGIN
			
			-- Devuelvo un mensaje de error
			SET @mensaje_error = 'La ruta seleccionada no comienza en la ciudad de la aeronave'
			RAISERROR(@mensaje_error, 12, 1)

		END
		ELSE
		BEGIN
			-- Compruebo que el servicio de la aeronave este tambien en la ruta seleccionada
			IF NOT EXISTS(SELECT * FROM DBAS.aeronaves tablaAeronaves, DBAS.serviciosPorRutas tablaSporR 
				WHERE tablaAeronaves.matricula_aeronave = @matricula_aeronave AND tablaSporR.codigo_ruta = @codigo_ruta AND tablaAeronaves.id_servicio = tablaSporR.codigo_ruta)
			BEGIN
				
				-- Devuelvo un mensaje de error
				SET @mensaje_error = 'El servicio de la aeronave no es posible para esta ruta'
				RAISERROR(@mensaje_error, 12, 1)

			END
			ELSE
			BEGIN
				-- Inserto el nuevo viaje con las caracteristicas seleccionadas
				INSERT INTO DBAS.viajes(fecha_salida, fecha_llegada_estimada, codigo_ruta, matricula_aeronave)
				VALUES(@fecha_salida, @fecha_llegada_estimada, @codigo_ruta, @matricula_aeronave)
			END
		END
	END
END;
GO

/* -- ABM Ciudades -- */

CREATE FUNCTION DBAS.rutasConCiudad(@nombre_ciudad varchar(100))
RETURNS @rutasConCiudad TABLE (codigo_ruta varchar(100))
AS
BEGIN
	INSERT INTO @rutasConCiudad(codigo_ruta)
	SELECT tablaRutas.codigo_ruta FROM DBAS.rutas tablaRutas, DBAS.ciudades tablaCiudades
	WHERE tablaCiudades.nombre_ciudad = @nombre_ciudad AND (tablaRutas.ciudad_origen_id = tablaCiudades.id_ciudad OR tablaRutas.ciudad_destino_id =tablaCiudades.id_ciudad)

	RETURN
END;
GO

CREATE PROCEDURE DBAS.bajaCiudad(@nombre_ciudad varchar(100))
AS
BEGIN
	DECLARE @GET_DATE datetime

	DECLARE @mensaje_error varchar(100)

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time


	IF EXISTS(SELECT * FROM DBAS.viajes tablaViajes, DBAS.rutasConCiudad(@nombre_ciudad) tablaRutasConCiudad
				WHERE tablaViajes.codigo_ruta = tablaRutasConCiudad.codigo_ruta AND tablaViajes.fecha_salida > @GET_DATE)
	BEGIN
		SET @mensaje_error = 'La ciudad seleccionada tiene viajes futuros'
		RAISERROR(@mensaje_error, 12, 1)
	END
	ELSE
	BEGIN
		UPDATE DBAS.ciudades SET habilitada_ciudad = 0 WHERE nombre_ciudad = @nombre_ciudad
		
		-- Deshabilito la ruta
		UPDATE tablaRutas SET tablaRutas.habilitada_ruta = 0
		FROM DBAS.rutas tablaRutas, DBAS.rutasConCiudad(@nombre_ciudad) tablaRutasConCiudad
		WHERE tablaRutas.codigo_ruta = tablaRutasConCiudad.codigo_ruta 
	END
END;
GO

CREATE PROCEDURE DBAS.cancelarPasajesBajaCiudad(@nombre_ciudad varchar(100))
AS
BEGIN
	DECLARE @GET_DATE datetime
	DECLARE @id_viaje bigint
	DECLARE @codigo_ruta bigint
	DECLARE @motivo_cancelacion varchar(100)
	DECLARE @ID_cancelacion bigint

	SELECT @GET_DATE = GET_DATE FROM DBAS.date_time

	-- Seteo el motivo de la cancelacion
	SET @motivo_cancelacion = 'Una ciudad fue dada de baja'

	-- Inserto la cancelacion con su motivo y obtengo su id para la asignacion de los pasajes y encomiendas que seran cancelados
	EXECUTE DBAS.cancelacionPasaje @motivo_cancelacion, @ID_cancelacion OUT

	DECLARE viajesCursor CURSOR FOR
	SELECT tablaViajes.id_viaje, tablaRutasConCiudad.codigo_ruta FROM DBAS.viajes tablaViajes, DBAS.rutasConCiudad(@nombre_ciudad) tablaRutasConCiudad
	WHERE tablaViajes.codigo_ruta = tablaRutasConCiudad.codigo_ruta AND tablaViajes.fecha_salida > @GET_DATE
	
	OPEN viajesCursor

	FETCH NEXT FROM viajesCursor
	INTO @id_viaje, @codigo_ruta

	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		UPDATE DBAS.pasajes SET id_cancelacion = @ID_cancelacion WHERE id_viaje = @id_viaje
		UPDATE DBAS.encomiendas SET id_cancelacion = @ID_cancelacion WHERE id_viaje = @id_viaje

		-- Deshabilito la ruta
		UPDATE DBAS.rutas SET habilitada_ruta = 0 WHERE codigo_ruta = @codigo_ruta

		--Deshabilito el viaje para que no se pueda vender pasajes ni encomiendas
		UPDATE DBAS.viajes SET habilitado_viaje = 0 WHERE id_viaje = @id_viaje AND fecha_salida > @GET_DATE
	

		FETCH NEXT FROM viajesCursor
		INTO @id_viaje, @codigo_ruta

	END

	CLOSE viajesCursor
	DEALLOCATE viajesCursor

END;
GO


/* -- Compra pasajes/encomiendas -- */

CREATE PROCEDURE DBAS.generarCompra(@id_comprador bigint, @tarjeta_Numero bigint, @tarjeta_Codigo bigint, @tarjeta_Fecha_de_vencimiento datetime, @tipo_tarjeta_id bigint, @cuoatas_elegidas smallint, @tipo_compra tinyint)
AS
BEGIN
	DECLARE @ID_tarjeta bigint

	--  Pregunto que tipo de compra es, si es 1 es por tarjeta sino en efectivo
	IF(@tipo_compra = 1)
	BEGIN
		
		-- Inserto la tarjeta con los datos que ingreso el cliente
		INSERT INTO DBAS.tarjetas(tarjeta_Numero, tarjeta_Codigo, tarjeta_Fecha_de_vencimiento, cuoatas_elegidas, tipo_tarjeta_id)
		VALUES (@tarjeta_Numero, @tarjeta_Codigo, @tarjeta_Fecha_de_vencimiento, @cuoatas_elegidas, @tipo_tarjeta_id)
		
		-- Obtengo la id de la tarjeta
		SET @ID_tarjeta = SCOPE_IDENTITY()

		-- Creo la compra insertando la id de la tarjeta y su comprador
		INSERT INTO DBAS.compras(id_cliente, tarjeta_id)
		VALUES(@id_comprador, @ID_tarjeta)

	END
	ELSE
	BEGIN
		-- Creo la compra con su comprador
		INSERT INTO DBAS.compras(id_cliente)
		VALUES(@id_comprador)
	END

END;
GO

--Cantidad de butacas libres de una aeronave
CREATE FUNCTION DBAS.cantidadButacasLibres(@matricula_aeronave varchar(100),@id_viaje bigint)
RETURNS bigint
AS
BEGIN
	DECLARE @cantidadPasajeros bigint
	SET @cantidadPasajeros = ISNULL((SELECT cantidad_pasajeros FROM DBAS.cantidadPasajerosPorViaje WHERE id_viaje = @id_viaje),0)

	DECLARE @cantidadButacas bigint
	SET @cantidadButacas = DBAS.cantidadButacas(@matricula_aeronave)

	DECLARE @asientosLibres bigint
	SET @asientosLibres = (@cantidadButacas - @cantidadPasajeros)

	RETURN @asientosLibres
END;
GO

-- Creo la vista para obtener los kg disponibles de encomienda de cada viaje
CREATE VIEW DBAS.cantidadKgEncomiendasPorViaje AS
SELECT encomiendas.id_viaje,SUM(encomienda_cliente_KG) as cantidad_kg FROM DBAS.encomiendas encomiendas
GROUP BY encomiendas.id_viaje
GO

--Cantidad de kg disponibles para encomiendas de una aeronave
CREATE FUNCTION DBAS.cantidadKgDisponibles(@matricula_aeronave varchar(100),@id_viaje bigint)
RETURNS real
AS
BEGIN
	DECLARE @cantidadOcupados real
	SET @cantidadOcupados = ISNULL((SELECT cantidad_kg FROM DBAS.cantidadKgEncomiendasPorViaje WHERE id_viaje = @id_viaje),0)

	DECLARE @cantidadMaxima real
	SET @cantidadMaxima = (SELECT kg_disponible_encomienda FROM DBAS.aeronaves WHERE matricula_aeronave = @matricula_aeronave)

	DECLARE @cantidadKgLibres real
	SET @cantidadKgLibres = (@cantidadMaxima - @cantidadOcupados)

	RETURN @cantidadKgLibres
END;
GO

--Butacas sin utilizar de una aeronave en un viaje
CREATE FUNCTION DBAS.butacasLibresEnViaje(@id_viaje bigint)
RETURNS @butacas TABLE (id_butaca bigint,numero_butaca smallint,tipo_butaca varchar(15),piso_butaca tinyint)
AS
BEGIN
	INSERT INTO @butacas
	SELECT id_butaca,numero_butaca,tipo_butaca,piso_butaca FROM DBAS.viajes viajes, DBAS.aeronaves aeronaves, DBAS.butacas butacas
	WHERE viajes.id_viaje = @id_viaje AND viajes.matricula_aeronave = aeronaves.matricula_aeronave
	AND butacas.matricula_aeronave = aeronaves.matricula_aeronave 
	EXCEPT
	(SELECT butacas.id_butaca,numero_butaca,tipo_butaca,piso_butaca 
	FROM DBAS.pasajes, DBAS.viajes viajes, DBAS.butacas butacas, DBAS.aeronaves aeronaves
	WHERE viajes.id_viaje = @id_viaje AND viajes.matricula_aeronave = aeronaves.matricula_aeronave 
	AND butacas.matricula_aeronave = aeronaves.matricula_aeronave AND pasajes.id_viaje = @id_viaje
	AND pasajes.id_butaca = butacas.id_butaca)
	RETURN
END;
GO


/* -- cancelacion pasajes/encomiendas -- */

-- La vista es creada para que la aplicacion me pueda mandar un INSERT simultaneo como si fuera el de un select, con los parametros de la vista
CREATE VIEW DBAS.PasajesCancelados AS
SELECT tablaCompras.id_compra_PNR, tablaCompras.id_cliente, 'motivo cancelacion' motivo_cancelacion, tablaPasajes.codigo_pasaje, tablaEncomiendas.codigo_encomienda
FROM DBAS.pasajes tablaPasajes, DBAS.encomiendas tablaEncomiendas, DBAS.compras tablaCompras
WHERE tablaPasajes.id_compra_PNR = tablaEncomiendas.id_compra_PNR AND tablaCompras.id_compra_PNR = tablaPasajes.id_compra_PNR 
GO

-- Creo un trigger para manejar los pasajes/Encomiendas cancelados en la vista
CREATE TRIGGER DBAS.cancelarPasajes ON DBAS.PasajesCancelados
INSTEAD OF INSERT
AS
BEGIN
	DECLARE @PNR bigint, @id_comprador bigint, @motivo_cancelacion varchar(100), @ID_cancelacion bigint, @codigo_pasaje bigint, @codigo_encomienda bigint , @mensaje_error varchar(100)

	-- Declaro un cursor para el manejo de los datos ingresados
	DECLARE cancelarCursor CURSOR FOR
	SELECT @PNR, @id_comprador, @motivo_cancelacion, @codigo_pasaje, @codigo_encomienda FROM inserted

	OPEN cancelarCursor

	-- Inserto lo que obtiene el cursor en las variables
	FETCH NEXT FROM cancelarCursor
	INTO @PNR, @id_comprador, @motivo_cancelacion, @codigo_pasaje, @codigo_encomienda

	-- Compruebo si la id de la compra y/o el cliente existen
	IF EXISTS(SELECT * FROM DBAS.compras WHERE id_compra_PNR = @PNR AND id_cliente = @id_comprador)
	BEGIN
		
		-- comienzo una transaccion por si hay datos que no corresponden
		BEGIN TRANSACTION cancelacionPE
		
		-- Inserto una cancelacion con los motivos del cliente y obtengo la id de la cancelacion 
		EXECUTE DBAS.cancelacionPasaje @motivo_cancelacion, @ID_cancelacion OUT

		WHILE @@FETCH_STATUS = 0
		BEGIN
			-- pregunto si existe el pasaje con el codigo ingresado y con el mismo PNR
			IF EXISTS(SELECT * FROM DBAS.pasajes WHERE codigo_pasaje = @codigo_pasaje AND id_compra_PNR = @PNR) AND @codigo_pasaje IS NOT NULL
			BEGIN
				-- Actualizo el pasaje con el codigo de cancelacion
				UPDATE DBAS.pasajes SET id_cancelacion = @ID_cancelacion WHERE codigo_pasaje = @codigo_pasaje
			END
			ELSE
			BEGIN
				-- Devuelvo un mensaje de error
				SET @mensaje_error = 'Hay un codigo de pasaje invalido'
				RAISERROR(@mensaje_error, 12, 1)

				CLOSE cancelarCursor
				DEALLOCATE cancelarCursor

				-- Vuelvo atras todos los cambios realizados
				ROLLBACK TRANSACTION cancelacionPE
				RETURN
			END	
			
			-- pregunto si existe la encomienda con el codigo ingresado y con el mismo PNR
			IF EXISTS(SELECT * FROM DBAS.encomiendas WHERE codigo_encomienda = @codigo_encomienda AND id_compra_PNR = @PNR) AND @codigo_encomienda IS NOT NULL
			BEGIN
				-- Actualizo la encomienda con el codigo de cancelacion
				UPDATE DBAS.encomiendas SET id_cancelacion = @ID_cancelacion WHERE codigo_encomienda = @codigo_encomienda
			END
			ELSE
			BEGIN
				-- Devuelvo un mensaje de error
				SET @mensaje_error = 'Hay un codigo de encomienda invalido'
				RAISERROR(@mensaje_error, 12, 1)

				CLOSE cancelarCursor
				DEALLOCATE cancelarCursor
				
				-- Vuelvo atras todos los cambios realizados
				ROLLBACK TRANSACTION cancelacionPE
				RETURN
			END
			
			-- Inserto lo que obtiene el cursor en las variables
			FETCH NEXT FROM cancelarCursor
			INTO @PNR, @id_comprador, @motivo_cancelacion, @codigo_pasaje, @codigo_encomienda

		END

		CLOSE cancelarCursor
		DEALLOCATE cancelarCursor

		COMMIT TRANSACTION cancelacionPE

	END
	ELSE
	BEGIN
		
		-- Devuelvo un mensaje de error
		SET @mensaje_error = 'El PNR ingresado es incorrecto'
		RAISERROR(@mensaje_error, 12, 1)

	END

END;
GO

